{
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | Target Indicators Documentation",
    "summary": "Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning. [Unreleased] Added Changed Deprecated Removed Fixed"
  },
  "api/TargetIndicators.BoundaryShape.html": {
    "href": "api/TargetIndicators.BoundaryShape.html",
    "title": "Enum BoundaryShape | Target Indicators Documentation",
    "summary": "Enum BoundaryShape Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public enum BoundaryShape Fields Name Description Ellipse Rectangle"
  },
  "api/TargetIndicators.BoundaryType.html": {
    "href": "api/TargetIndicators.BoundaryType.html",
    "title": "Enum BoundaryType | Target Indicators Documentation",
    "summary": "Enum BoundaryType Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public enum BoundaryType Fields Name Description Absolute CompassTape Padded Unbounded"
  },
  "api/TargetIndicators.Ellipse.html": {
    "href": "api/TargetIndicators.Ellipse.html",
    "title": "Struct Ellipse | Target Indicators Documentation",
    "summary": "Struct Ellipse Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public struct Ellipse Constructors Ellipse(Vector2, float, float) Declaration public Ellipse(Vector2 center, float semiMajorAxisLength, float semiMinorAxisLength) Parameters Type Name Description Vector2 center float semiMajorAxisLength float semiMinorAxisLength Properties Center Declaration public readonly Vector2 Center { get; } Property Value Type Description Vector2 SemiMajorAxisLength Declaration public readonly float SemiMajorAxisLength { get; } Property Value Type Description float SemiMinorAxisLength Declaration public readonly float SemiMinorAxisLength { get; } Property Value Type Description float"
  },
  "api/TargetIndicators.TargetIndicator.html": {
    "href": "api/TargetIndicators.TargetIndicator.html",
    "title": "Struct TargetIndicator | Target Indicators Documentation",
    "summary": "Struct TargetIndicator Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public struct TargetIndicator Constructors TargetIndicator(TargetIndicatorId, Transform, Pose, bool) Declaration public TargetIndicator(TargetIndicatorId id, Transform target, Pose screenPose, bool isOutsideBoundary) Parameters Type Name Description TargetIndicatorId id Transform target Pose screenPose bool isOutsideBoundary TargetIndicator(TargetIndicatorId, Transform, Vector3, Quaternion, bool) Declaration public TargetIndicator(TargetIndicatorId id, Transform target, Vector3 screenPoint, Quaternion rotation, bool isOutsideBoundary) Parameters Type Name Description TargetIndicatorId id Transform target Vector3 screenPoint Quaternion rotation bool isOutsideBoundary Properties Default Declaration public static TargetIndicator Default { get; } Property Value Type Description TargetIndicator Id Declaration public readonly TargetIndicatorId Id { get; } Property Value Type Description TargetIndicatorId IsOutsideBoundary Declaration public readonly bool IsOutsideBoundary { get; } Property Value Type Description bool ScreenPose Declaration public readonly Pose ScreenPose { get; } Property Value Type Description Pose Target Declaration public readonly Transform Target { get; } Property Value Type Description Transform"
  },
  "api/TargetIndicators.TargetIndicatorBoundaryVisualizer.html": {
    "href": "api/TargetIndicators.TargetIndicatorBoundaryVisualizer.html",
    "title": "Class TargetIndicatorBoundaryVisualizer | Target Indicators Documentation",
    "summary": "Class TargetIndicatorBoundaryVisualizer Inheritance object TargetIndicatorBoundaryVisualizer Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public class TargetIndicatorBoundaryVisualizer : MonoBehaviour Constructors TargetIndicatorBoundaryVisualizer() Declaration public TargetIndicatorBoundaryVisualizer()"
  },
  "api/TargetIndicators.TargetIndicatorId.html": {
    "href": "api/TargetIndicators.TargetIndicatorId.html",
    "title": "Struct TargetIndicatorId | Target Indicators Documentation",
    "summary": "Struct TargetIndicatorId Implements IEquatable<TargetIndicatorId> Inherited Members ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public readonly struct TargetIndicatorId : IEquatable<TargetIndicatorId> Constructors TargetIndicatorId(Guid) Declaration public TargetIndicatorId(Guid id) Parameters Type Name Description Guid id Properties Default Declaration public static TargetIndicatorId Default { get; } Property Value Type Description TargetIndicatorId Id Declaration public Guid Id { get; } Property Value Type Description Guid Methods Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides ValueType.Equals(object) Equals(TargetIndicatorId) Declaration public bool Equals(TargetIndicatorId other) Parameters Type Name Description TargetIndicatorId other Returns Type Description bool GetHashCode() Declaration public override int GetHashCode() Returns Type Description int Overrides ValueType.GetHashCode() Operators operator ==(TargetIndicatorId, TargetIndicatorId) Declaration public static bool operator ==(TargetIndicatorId a, TargetIndicatorId b) Parameters Type Name Description TargetIndicatorId a TargetIndicatorId b Returns Type Description bool operator !=(TargetIndicatorId, TargetIndicatorId) Declaration public static bool operator !=(TargetIndicatorId a, TargetIndicatorId b) Parameters Type Name Description TargetIndicatorId a TargetIndicatorId b Returns Type Description bool Implements IEquatable<T>"
  },
  "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsRemovedDelegate.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsRemovedDelegate.html",
    "title": "Delegate TargetIndicatorManager.TargetIndicatorsRemovedDelegate | Target Indicators Documentation",
    "summary": "Delegate TargetIndicatorManager.TargetIndicatorsRemovedDelegate Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public delegate void TargetIndicatorManager.TargetIndicatorsRemovedDelegate(ReadOnlySpan<TargetIndicatorId> span) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span Constructors TargetIndicatorsRemovedDelegate(object, nint) Declaration public TargetIndicatorsRemovedDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods BeginInvoke(ReadOnlySpan<TargetIndicatorId>, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ReadOnlySpan<TargetIndicatorId> span, AsyncCallback callback, object @object) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Invoke(ReadOnlySpan<TargetIndicatorId>) Declaration public virtual void Invoke(ReadOnlySpan<TargetIndicatorId> span) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span"
  },
  "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsUpdatedDelegate.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsUpdatedDelegate.html",
    "title": "Delegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate | Target Indicators Documentation",
    "summary": "Delegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public delegate void TargetIndicatorManager.TargetIndicatorsUpdatedDelegate(ReadOnlySpan<TargetIndicator> span) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span Constructors TargetIndicatorsUpdatedDelegate(object, nint) Declaration public TargetIndicatorsUpdatedDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods BeginInvoke(ReadOnlySpan<TargetIndicator>, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ReadOnlySpan<TargetIndicator> span, AsyncCallback callback, object @object) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Invoke(ReadOnlySpan<TargetIndicator>) Declaration public virtual void Invoke(ReadOnlySpan<TargetIndicator> span) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span"
  },
  "api/TargetIndicators.TargetIndicatorManager.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.html",
    "title": "Class TargetIndicatorManager | Target Indicators Documentation",
    "summary": "Class TargetIndicatorManager Inheritance object TargetIndicatorManager Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public class TargetIndicatorManager : MonoBehaviour Constructors TargetIndicatorManager() Declaration public TargetIndicatorManager() Properties BottomPadding Declaration public float BottomPadding { get; set; } Property Value Type Description float BoundaryShape Declaration public BoundaryShape BoundaryShape { get; set; } Property Value Type Description BoundaryShape BoundaryType Declaration public BoundaryType BoundaryType { get; set; } Property Value Type Description BoundaryType Camera Declaration public Camera Camera { get; set; } Property Value Type Description Camera Ellipse Declaration public Ellipse Ellipse { get; } Property Value Type Description Ellipse Height Declaration public float Height { get; set; } Property Value Type Description float LeftPadding Declaration public float LeftPadding { get; set; } Property Value Type Description float MaxTargets Declaration public int MaxTargets { get; } Property Value Type Description int Rectangle Declaration public Rect Rectangle { get; } Property Value Type Description Rect RightPadding Declaration public float RightPadding { get; set; } Property Value Type Description float TopPadding Declaration public float TopPadding { get; set; } Property Value Type Description float TrackedTargetsCount Declaration public int TrackedTargetsCount { get; } Property Value Type Description int Width Declaration public float Width { get; set; } Property Value Type Description float Methods GetScreenPose(in Vector3, out bool) Declaration public Pose GetScreenPose(in Vector3 worldSpacePosition, out bool isOutsideBounds) Parameters Type Name Description Vector3 worldSpacePosition bool isOutsideBounds Returns Type Description Pose IsOutsideBounds(in Vector3) Declaration public bool IsOutsideBounds(in Vector3 screenPoint) Parameters Type Name Description Vector3 screenPoint Returns Type Description bool RemoveAllTargets() Declaration public void RemoveAllTargets() TryAddTarget(Transform, out TargetIndicator) Declaration public bool TryAddTarget(Transform target, out TargetIndicator targetIndicator) Parameters Type Name Description Transform target TargetIndicator targetIndicator Returns Type Description bool TryGetTargetIndicator(TargetIndicatorId, out TargetIndicator) Declaration public bool TryGetTargetIndicator(TargetIndicatorId targetIndicatorId, out TargetIndicator targetIndicator) Parameters Type Name Description TargetIndicatorId targetIndicatorId TargetIndicator targetIndicator Returns Type Description bool TryRemoveTarget(TargetIndicatorId) Declaration public bool TryRemoveTarget(TargetIndicatorId targetIndicatorId) Parameters Type Name Description TargetIndicatorId targetIndicatorId Returns Type Description bool Events TargetIndicatorsAdded Declaration public event TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsAdded Event Type Type Description TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsRemoved Declaration public event TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorsRemoved Event Type Type Description TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorsUpdated Declaration public event TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsUpdated Event Type Type Description TargetIndicatorManager.TargetIndicatorsUpdatedDelegate"
  },
  "api/TargetIndicators.html": {
    "href": "api/TargetIndicators.html",
    "title": "Namespace TargetIndicators | Target Indicators Documentation",
    "summary": "Namespace TargetIndicators Classes TargetIndicatorBoundaryVisualizer TargetIndicatorManager Structs Ellipse TargetIndicator TargetIndicatorId Enums BoundaryShape BoundaryType Delegates TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate"
  },
  "get-target-indicators.html": {
    "href": "get-target-indicators.html",
    "title": "",
    "summary": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "summary": ""
  },
  "introduction.html": {
    "href": "introduction.html",
    "title": "Introduction | Target Indicators Documentation",
    "summary": "Introduction"
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Target Indicators | Target Indicators Documentation",
    "summary": "Target Indicators Target Indicators is a Unity package that enables you to create visual indicators to track world-space targets. Guide users to points of interest, waypoints, or other in-game places. Customize indicators to fit your project's style and requirements. The package integrates with any UI system, offering an API to calculate and bound screen-space positions for any target. It includes ready-to-use Sample Assets for a quick, low-code setup, also serving as an excellent references for building fully custom UI indicators. Note Get Target Indicators on the Unity Asset Store. Highlights Target indicators focuses on simplicity and high performance. The following highlights are what you can expect from this package: Works with any UI system* Highly configurable at edit and runtime No heap allocations after initialization Does not rely on Object.Find or any variations of scene searching at runtime Does not rely on GetComponent Simple and minimal sample scenes Works with traditional displays and XR HMDs Note *The package has a dependency on com.unity.ugui to support the samples and demo scenes. Dependencies The following dependencies are required for target indicators. Unity version Unity 6000.0 or newer Packages com.unity.inputsystem 1.14.0 for samples com.unity.ugui 2.0.0 for samples"
  },
  "manual/install-package.html": {
    "href": "manual/install-package.html",
    "title": "Install package | Target Indicators Documentation",
    "summary": "Install package Once purchased, follow these steps to add the Target Indicators package to your project: Open the package manager via Window > Package Management > Package Manager. In the package manager window navigate to My Assets and search for Target Indicators and click Download. After the packages has downloaded you should find the package contents in the Project Window > Packages > Target Indicators. Import samples If you want a premade indicator visualizer system using Unity UI you can import the Starter Assets: Navigate to Package Manager > In Project > Target Indicators > Samples and import the Starter Assets. After the starter assets have imported you can find them in Assets > Samples > Target Indicators > [version] > Starter Assets. Refer to the samples documentation to learn more."
  },
  "manual/samples/sample-scenes.html": {
    "href": "manual/samples/sample-scenes.html",
    "title": "Sample scenes | Target Indicators Documentation",
    "summary": "Sample scenes The sample scenes are located in Assets/Samples/Target Indicators/[version]/StarterAssets/Example Assets/Scenes. The structure of each scene includes a group of helper scene objects that are unrelated to target indicators but required for the samples scene to work, such as the environment objects, directional light, event system, etc. The target indicators related scripts are located under the --- Target Indicator Managers --- GameObject in the hiearchy. This is where you can find how target indicators are setup in the scene and the targets that are being tracked. The visual indicators that get instantiated for the UI uses uGUI (Unity UI) and are parented under the Canvas beneath the --- UI --- GameObject in the hiearchy. Scene interactions Each scene has a simple first person controller script attached the to scenes Camera GameObject. To enable input while in play mode, press the Escape key on the keyboard to enable focus. A visual indicator of the current focus state can be found in the top right of the Game window and looks like a gray square. The indicator will be white when focused and gray when unfocused. While focused, click the mouse anywhere in the Game window to hide the cursor. Pressing Escape will unfocus the game and reveal the cursor. Focus and unfocus the game to edit the target indicator manager settings and experiement without having to exit play mode. When the game is focused you can move around with WASD and look around with the mouse. Scenes There are three scenes to demonstrate a few variations of using target indiecators. The following sections describes each scene in more detail. Simple Target Indicators Demo This scene demonstrates a minimal version of target indicators and is a good starting point. It uses only one visual indicator manager and one indicator visualizer prefab. The assigned default visual indicator prefab assigned in the visual indicator manager is what indicators get instantiated in the scene. They are parented to the Canvas under the Target Indicators Content GameObject. The Simple Targets Indicators Setup Example GameObject contains a script SimpleTargetIndicatorSetupExample that shows a minimal code example for assigning targets to the target indicator manager on Start. Note Changing the target indicator manager's boundary type to compass tape will stop the target indicators from updating. Compass tape boundary types require special configuration. Refer to compass tape visual indicator manager to learn how to work with a compass tape target indicator. Compass Tape Target Indicators Demo This scene demonstrates how to setup a compass tape target indicator. The target indicator manager's BoundaryType is set to CompassTape and uses the CompassTapeVisualIndicator on the Compass Tape Visual Indicator Manager GameObject. The default visual indicator prefab uses the CompassTapeVisualIndicator prefab. The compass tape visual indicators are instantiated and parented to the UI Compass Tape Indicators Content GameObject under the Canvas. The Compass Tape Target Indicators Setup Example GameObject contains a script CompassTapeTargetIndicatorsSetupExample that shows a minimal code example for assigning targets to the compass target visual indicator manager on Start. Multiple Target Indicator Categories Demo This scene demonstrates using multiple target indicator managers for different visual indicator categories. There are two target indecator managers that both use padded boundary type but with different padding values. The reason is because one of the visual indicators, the Enemy Target Indicator found in the Example Assets prefabs folder, has an offset raised by 10 pixels. Therefore it uses a target indicator manager with an adjusted boundary so it aligns with the other visual indicators on the screen. The Multiple Target Categories Setup Example GameObject contains a script MultipleTargetIndicatorCategoriesExample that shows a minimal code example for assigning targets with different visual indicators to two different visual indicator managers on Start."
  },
  "manual/samples/samples-overview.html": {
    "href": "manual/samples/samples-overview.html",
    "title": "Samples Overview | Target Indicators Documentation",
    "summary": "Samples Overview The Sample Assets provide a collection of scenes and assets that demonstrate the features of Target Indicators. They also include preconfigured scripts and prefabs for visual indicators. Use these assets directly for immediate implementation, or as templates for your custom variants. Import the samples To import the sample assets into your project refer to Import samples. Sample assets The assets are grouped into two parts: Core Assets Core assets are located in Assets/Samples/Target Indicators/[version]/StarterAssets/Core Assets and contains the set of scripts, prefabs, and textures for you to use directly or as a foundation for your own visual indicators. Example Assets Example assets are located in Assets/Samples/Target Indicators/[version]/StarterAssets/Example Assets and contains the scripts, prefabs, and other assets needed for the sample scenes. Visual indicators The samples scenes rely on two main components for visualizing target indicators: Visual indicator manager This component interacts with the target indicator manager and handles instantiating visual indicator prefabs and updating their state. To learn more about how to setup and use the sample's visual indicator manager, refer to visual indicator manager component. Visual indicator This component gets attached to prefabs and is what the visual indicator manager instantiates for new visual indicators. To learn more about how to setup and use the sample's visual indicator, refer to visual indicator component."
  },
  "manual/samples/samples.html": {
    "href": "manual/samples/samples.html",
    "title": "Samples | Target Indicators Documentation",
    "summary": "Samples Refer to the following topics to understand the samples and how to use them: Topic Description Samples Overview Understand how the samples work. Visual indicator manager component Understand how to setup and use the visual indicator manager component. Visual indicator component Understand how to setup and use the visual indicator component with prefabs. Sample scenes Understand the different sample scenes."
  },
  "manual/samples/visual-indicator-component.html": {
    "href": "manual/samples/visual-indicator-component.html",
    "title": "Visual indicator component | Target Indicators Documentation",
    "summary": "Visual indicator component The visual indicator component is instantiated by the VisualIndicatorManager and controls each instance of a visual indicator prefab. References and settings The following sections describes each references and settings of the component: Indicator content This is the root content that will be visible in the UI. Any imagery or text that is part of the core visual indicator should be parented to this transform. Rotation content This is the root content for image or text that will be rotated to point at the target the visual indicator is tracking. Any arrows or other imagery should be parented to this transform. Indicator visibility This determines how the indicator content will be visibile for a given state. This property does not affect the rotation content visibility. Refer to Indicator visibility to learn more about the options. Rotation content visibility This determines how the indicator's rotation content will be visible for a given state. This property does not affect the indicator visibility. Refer to Indicator visibility to learn more about the options. Indicator visibility There are four types of indicator visibility that determines how visual indicator's content and their rotation content will be visible for any given state: Never The content is never visible. This is typically only useful for rotation content where you don't want to show an arrow or any additional content that rotates to point at a target. Always The content is always visible. Outside boundary The content is only visible when the target is outside the boundary. This is typically used for the rotation content when you want an arrow to point at the target when it is outside the boundary. Inside boundary The content is only visible when the taret is inside the boundary. This is typically used for compass tape visual indicators where you only want the indicator visible when inside the bounds of the compass tape. Set up a prefab The visual indicator prefabs provided in in Assets/Samples/Target Indicators/[version]/StarterAssets/Core Assets/Prefabs is a good reference for building your own indicators. Create a prefab variant to use it as a template or make a new one from scratch. Visual indicator The following image labels the key components of a visual indicator. The core indicator content. Notice in the hiearchy all the images representing the visualizer are parented to a single Content GameObject that is reference in the IndicatorContent field of the VisualIndicator inspector. The arrow image that is parented to the Rotation Content GameObject in the hiearchy. The VisualIndicator component and it's assigned references and settings. Compass tape visual indicator The CompassTapeVisualIndicator inherits from the base VisualIndicator. Like the base visual indicator, the compass tape visual indicator has the same configuration. The reason for a special CompassTapeVisualIndicator component is to handle the unique interpreting of screen pose values for compass tape target indicators. The core indicator content. Notice in the hiearchy the images representing the visualizer are parented to a single Content GameObject that is reference in the IndicatorContent field of the CompassTapeVisualIndicator inspector. The CompassTapeVisualIndicator component and it's assigned references and settings. Typically the RotationContentVisibility is unused and set to Never."
  },
  "manual/samples/visual-indicator-manager-component.html": {
    "href": "manual/samples/visual-indicator-manager-component.html",
    "title": "Visual indicator manager component | Target Indicators Documentation",
    "summary": "Visual indicator manager component The visual indicator manager component works with the TargetIndicatorManager and instantiates visual indicator prefabs and updates their state. There are several properties to configure for the component to work. References and settings The following sections describes each reference and settings of the component: Default visual indicator prefab This is a reference to the visual indicator prefab that will be instantiated in the UI by default when a target is added. You can assign this in the inspector or change it at runtime by assigning the DefaultVisualIndicatorPrefab. Target indicator manager This is a reference to the TargetIndicatorManager component in the scene that you want this visual indicator manager to interact with and respond to. Content This is the RectTransform in the Canvas you want to instantiate your visual indicators and parent them to. Add indicator mode This property controls whether visual indicators should automatically be created when the TargetIndicatorManager adds targets. If set to manual, it will only instantiate visual indicators when you call TargetIndicatorManager.AddTargetIndicator. API The visual indicator manager offers several APIs for you to have more control over what visual indicators get instantiated and when. Add target indicator If you want the visual indicator manager to track every target that is added to the target indicator manager you can add targets directly to the TargetIndicatorManager and leave the AddIndicatorMode to Auto. This way the visual indicator manager will automatically instantiate and update visual indicators. If you want the visual indicator manager to track specific targets from the target indicator manager, set the AddIndicatorMode to Manual and use one of the following APIs: AddTargetIndicator(Transform target) This API takes a transform of a target to track and adds it to the target indicator manager. It instantiates the default visual indicator prefab. AddTargetIndicator(Transform target, VisualIndicator indicatorPrefab) This API takes a transform of a target to track and adds it to the target indicator manager. It instantiates a new instance from the indicatorPrefab passed in as the second argument. Use this when you want a specific visual indicator for a target. Hide a visual Indicator VisualIndicator.HideVisualIndicator will hide the content and rotation content of a visual indicator without disabling the component at the root. Use this to temporarily hide a visual indicator if you don't want to destroy it. Show a visual Indicator VisualIndicator.ShowVisualIndicator This API shows the content and rotation content of a visual indicator that was previously hidden. Use this to show hidden indicators from HideVisualIndicator. Visual indicators are shown when first instantiated. RemoveTargetIndicator VisualIndicator.RemoveTargetIndicator removes a target from the target indicator manager. Use this when you are done tracking a target and want to destroy the visual indicator. Compass tape visual indicator manager The CompassTapeVisualIndicatorManager inhertis from VisualIndicatorManager and is specialized for handling target indicator managers with a CompassTape boundary type. It follows the same setup pattern. Use this class as an example to inherit the base visual indicator manager overriding the functionality with custom behavior. It requires a special implementation of CompassTapeVisualIndicator prefab for its DefaultVisualIndicatorPrefab. Refer to compass tape visual indicator for more information."
  },
  "manual/support-and-feedback.html": {
    "href": "manual/support-and-feedback.html",
    "title": "Support and Feedback | Target Indicators Documentation",
    "summary": "Support and Feedback If you need assistance, have questions, want to provide feedback, request new features, or report a bug, please email me at: targetindicatorshelp@gmail.com To help me assist you efficiently, please include the following information in your email: Subject Line: Clearly state the purpose of your email with one of the following: \"Feedback\" \"Question\" \"Feature Request\" \"Bug Report\" For Bug Reports: Steps to teproduce: Provide minimal, clear steps to consistently reproduce the issue. Supporting media: Include relevant pictures or videos if they help illustrate the problem. Versions: Specify the Unity version and the Target Indicators package version you are using."
  },
  "manual/user-guide.html": {
    "href": "manual/user-guide.html",
    "title": "User Guide | Target Indicators Documentation",
    "summary": "User Guide Refer to the following topics to understand target indicators and how to use them: Topic Description Overview Understand how target indicators work. Target Indicator Manager Understand how to configure and use the Target Indicator Manager component. Target Indicator Understand how to use target indicators created by the target indicator manager. uGUI indicators Understand how to configure target indicators for Unity UI. XR indicators Understand how to configure target indicators for XR."
  },
  "manual/user_guide/overview.html": {
    "href": "manual/user_guide/overview.html",
    "title": "Overview | Target Indicators Documentation",
    "summary": "Overview Target Indicators provide pixel-based screen coordinates for 3D world-space positions. These coordinates represent the screen space projection of a target, even when it's off-screen. If configured, the system bounds these screen coordinates to the edges of the display, indicating the target's nearest direction. This capability is useful in games or applications when guiding users to objectives or other points of interest that are not currently in the camera's view. Beyond basic positioning, Target Indicators also offer contextual data about a target. This includes, for example, the rotation required to point an arrow directly at the target in screen space, or whether the target lies outside a predefined screen boundary. Main components The target indicator system is comprised of two main components. Target Indicator Manager The Target Indicator Manager handles all tracked targets. It calculates the necessary data for positioning visual indicators on the screen. You can use it to manage the lifecycle events of indicators, receiving notifications when they change, or retrieve screen-space data directly for custom lifecycle control. This manager integrates with any UI system, as it solely focuses on converting world-space positions to screen-space coordinates. Its configurable options allow you to define the boundary type, shape, and size, customizing the screen boundary for your application's requirements. Tip The Target Indicators package offers Samples that provides prefabs using uGUI that you can customize for your project's needs if you don't want to build your own visual indicators. Target Indicator A Target Indicator is the data structure generated by the target indicator manager that holds screen-space information for visualizing a tracked target. While it functions as a conceptual component within the system's design, a TargetIndicator is a C# struct, not a Unity Component that attaches to GameObjects. This struct contains relevant information about a tracked target, such as the screen pose (coordinates and rotation), the target it's tracking, and if it's outside the configured boundary."
  },
  "manual/user_guide/target-indicator-manager.html": {
    "href": "manual/user_guide/target-indicator-manager.html",
    "title": "Target Indicator Manager | Target Indicators Documentation",
    "summary": "Target Indicator Manager The TargetIndicatorManager component is central to Target Indicators. It manages the lifecycle of all tracked targets, handling their addition, updates, and removal. This manager generates the screen-space data needed to position visual indicators. The following sections explain how to use the target indicator manager. Important By default Target Indicators does not display any UI on the scene. It only returns screen coordinates for you to display your own indicators. If you are interested in a prebuilt visualized indicator you can import the sample's starter assets which provides a solution with Unity UI. Refer to the samples docs to learn more about how to configure the prebuilt indicators. Scene Setup Add the TargetIndicatorManager to a GameObject in the hiearchy and edit the configuration to your projects needs. Configure the Target Indicator Manager The TargetIndicatorManager has several properties that can be edited within the inspector or set at runtime. The following sections explains each property in more detail. Camera The camera is used for calculating the screen space coordinates of each target. By default, when the TargetIndicatorManager component is added or reset it will assign the camera in your scene with the MainCamera tag. If no camera has the MainCamera tag it will fallback to using the first camera in the scene. Assign the camera that you will be using to display target indicators. To assign the camera reference at runtime, use TargetIndicatorManager.Camera. Boundary type The BoundaryType property controls how visual indicators behave when their target moves off-screen. For example indicators can be bound by the screen edges or have no boundary at all. There are four boundary types: Padded This boundary type clamps target indicators to the screen edges while applying an adjustable padding defined in pixels. Indicators automatically adapt to changes in screen size, maintaining their padding and visibility. Padded boundary is common for indicating waypoints, enemies, and points of interest. Absolute This boundary type clamps target indicators to the screen with a fixed size defined in pixels. It will not change if the screen size changes. Absolute boundary is common in first person games where you want to indicate the direction a player or other character is attacking from when not directly in front of the user. Compass Tape This boundary type maps off-screen targets to a horizontal range, simulating a compass tape. Unlike other boundary types, it does not provide pixel-based screen coordinates. Instead, it offers a normalized value between 0 and 1 for the TargetIndicator.ScreenPose.x component, representing the target's horizontal direction on the tape. To learn more about how to use the screen pose for a target indicator on a compass tape refer to Interpret the screen pose. Unbounded This boundary type places visual indicators directly at the target's screen pose without any clamping. Consequently, if the target moves off-screen, its corresponding visual indicator will also move off-screen. Boundary shape When using Padded or Absolute boundary types, configure the shape of the boundary with the BoundaryShape property. There are two boundary shapes: Rectangle TargetIndicatorManager.Ellipse represents the rectangle data generated by the currnet configuration. Ellipse TargetIndicatorManager.Ellipse represents the ellipse data generated by the current configuration. Padding When BoundaryType is set to Padded, you can define the pixel distance between the screen edges and the visual indicator's boundary. Padding can be independently configured for the Top, Bottom, Left, and Right edges. These properties are ignored if BoundaryType is not Padded. Size When BoundaryType is set to Absolute, the boundary's dimensions are defined by the Width and Height properties. Unlike other boundary types, this size remains fixed and does not adapt to changes in screen size. These properties are ignored if BoundaryType is not Absolute. Visualize the boundary You can visualize your current configuration at edit time and at runtime with the TargetIndicatorBoundaryVisualizer component. The following sections describe how to use the TargetIndicatorBoundaryVisualizer to visualize the configured boundary. Add visualizer Attach the TargetIndicatorBoundaryVisualizer component by clicking the Add Boundary Visualizer button on the bottom of the target indicator manager component. Once added, you can remove the visualizer by clicking the Remove Boundary Visualizer button. Note Only BoundaryType.Padded and BoundaryType.Absolute can be visualized with the built in visualizer. Edit visualizer Boundary line color and line width properties are available in the inspector to modify the boundary visualizer. This is useful if you have multiple target indicator managers and need to distinguish easily between them. API The following sections describe how to use the target indicator manager API. Add a target To add a target to track use TryAddTarget as shown in the following code example: public void TryAddTargetExample(TargetIndicatorManager manager, Transform target) { var wasAdded = manager.TryAddTarget(target, out var targetIndicator); if (!wasAdded) { // Failed to add target because max limit of targets is reached. // Handle error. return; } // Successfully added target. } The max number of targets that can be tracked at once is 100. TryAddTarget can only fail if you try to add more than 100 targets. To get the current number of tracked targets use TrackedTargetsCount. If you need more than 100 (god bless), you can use multiple target indicator managers. Keep track of the returned TargetIndicator.TrackedIndicatorId in the out parameter to know which target indicator corresponds to a target. Remove a target To remove a target from being tracked use TryRemoveTarget as shown in the following code example: public void TryRemoveTargetExample(TargetIndicatorManager manager, TargetIndicatorId id) { var wasRemoved = manager.TryRemoveTarget(id); if (!wasRemoved) { // Failed to remove target because the target indicator ID was invalid. // Handle error. return; } // Successfully removed target. } Removing a target can only fail if you pass an invalid TargetIndicatorId. Remove all targets To remove all targets at once use RemoveAllTargets as shown in the following code example: public void RemoveAllTargetsExample(TargetIndicatorManager manager) { manager.RemoveAllTargets(); // Successfully removed all tracked targets. } Tip If you just want to stop receiving updates you can disable the TargetIndicatorManager component. Re-enabling it will resume tracking targets. Get a target To check if a target indicator is being tracked use TryGetTargetIndicator as shown in the following code example: public void GetATargetIndicatorExample( TargetIndicatorManager manager, TargetIndicatorId id) { var didGet = manager.TryGetTargetIndicator(id, out var targetIndicator); if (!didGet) { // Failed to get target because target indicator ID was invalid. // Handle error. return; } // Successfully received target indicator. } Get screen pose If you want to get the screen pose of any world space position that adherers to your current boundary configuration, use GetScreenPose. This can be useful if you want to control your own life cycle, or if you only need a one time update, or you need infrequent updates for a target's screen pose. The following code example shows you how to use GetScreenPose: public void GetScreenPoseExample( TargetIndicatorManager manager, Vector3 worldSpacePosition) { var screenPose = manager.GetScreenPose(worldSpacePosition, out var isOutsideBounds); // screenPose.position.x = horizontal axis coordinate in screen space (pixels). // screenPose.position.y = vertical axis coordinate in screen space (pixels). // screenPose.position.z = depth from the camera in world space (meters). // screenPose.rotation = direction to target in screen space. // isOutsideBounds = true if the screenPose.position is outside the configured bounds. // The depth from the camera is ignored in this check. } Is outside boundary Each TargetIndicator contains an IsOutsideBoundary property that you can use to know if a target indicator is outside the bounds of the current configured boundary when the TargetIndicator was created. If you want to know if any Vector3 position is outside the current boundary configuration use TargetIndicatorManager.IsOutsideBoundary as shown in the following example: public void IsOutsideBoundaryExample( TargetIndicatorManager manager, Vector3 worldSpacePosition) { var isOutsideBounds = manager.IsOutsideBounds(worldSpacePosition); // isOutsideBounds = true if the screen pose coordinates are outside the // configured bounds. The depth from the camera is ignored in this check. } Important For BoundaryType.CompassTape and BoundaryType.Unbounded the IsOutsideBoundary property will always be false. BoundaryType.Compass requires knowledge about your specific compass tape setup to determine if it's outside the boundary.sTape Refer to samples as a reference for how you can check if the target indicator is outside of the boundary. Life cycle events While enabled, the TargetIndicatorManager component will check for changes every frame. If any anchors were added, updated, or removed, TargetIndicatorManager will invoke TargetIndicatorsAdded, TargetIndicatorsUpdated, and TargetIndicatorsRemoved events respectively. Each event passes a ReadOnlySpan that wraps an underlying array. This avoids heap allocations and slices the array to the size of changes that occurred since the last time the events were invoked. The following code example shows how you can subscribe to these events and iterate over the spans they pass: public void LifeCycleExample(TargetIndicatorManager manager) { manager.TargetIndicatorsAdded += OnTargetIndicatorsAdded; manager.TargetIndicatorsUpdated += OnTargetIndicatorsUpdated; manager.TargetIndicatorsRemoved += OnTargetIndicatorsRemoved; } void OnTargetIndicatorsAdded(ReadOnlySpan<TargetIndicator> added) { foreach (var targetIndicator in added) { var screenPose = targetIndicator.ScreenPose; } } void OnTargetIndicatorsUpdated(ReadOnlySpan<TargetIndicator> updated) { foreach (var targetIndicator in updated) { var updatedScreenPose = targetIndicator.ScreenPose; } } void OnTargetIndicatorsRemoved(ReadOnlySpan<TargetIndicatorId> removed) { foreach (var targetIndicatorId in removed) { // TargetIndicatorId was removed. } } You can disable the TargetIndicatorManager component to stop receiving life cycle events and control your own life cycle and rely on the TargetIndicatorManager exclusively for pose and boundary checks. Using multiple target indicator managers Some applications might require multiple boundary types or multiple configurations. You can have multiple TargetIndicatorManager components in your scene to get more complex designs. For example if you use BoundaryType.CompassTape you will only get indicators to display on the compass tape but might not know what target they correspond to. You can have a second TargetIndicatorManager that is configured to use BoundaryType.Unbounded that marks the same target with a matching icon as used in your compass tape visualizer to indicate which target represents which marker in your compass tape indicator. The Samples provides an example of how to configre multiple target indicator managers."
  },
  "manual/user_guide/target-indicator.html": {
    "href": "manual/user_guide/target-indicator.html",
    "title": "Target Indicator | Target Indicators Documentation",
    "summary": "Target Indicator A Target Indicator is a C# struct that contains the properties necessary for placing indicators on the screen to track a target. The following sections explains the target indicator properties and how they map to the screen in more detail. Target indicator id The TargetIndicatorId property is the unique ID associated with a target indicator. It is generated by the Target indicator manager for each target and persists until the target is removed. If a target is added back to the target indicator manager after it has been removed, it will have a new target indicator ID. Target The target is the transform that the target indicator is tracking. The position of the target is what gets transformed to the screen coordinates for the target indicator. Screen pose The ScreenPose property is a Pose that contains the position and rotation of the target indicator for placement of a visual indicator. The values stored in the position and rotation of the pose differ between the boundary type when the target indicator was created. Refer to interpret the screen pose to learn how to use the respective pose values. Is outside boundary The IsOutsideBoundary property indicates if the screen pose of the target is outside of the boundary configured by the target indicator manager when the target indicator was created. The IsOutsideBoundary property will not update on existing target indicators structs if the boundary changes. You should wait for an updated target indicator an update to get the updated state or use TargetIndicatorManager.IsOutsideBoundary. Important For BoundaryType.CompassTape and BoundaryType.Unbounded the IsOutsideBoundary property will always be false. BoundaryType.Compass requires knowledge about your specific compass tape setup to determine if it's outside the boundary.sTape Refer to samples as a reference for how you can check if the target indicator is outside of the boundary. Screen coordinates Target indicators uses screen coordinates in pixels to describe the placement of a target indicator. The bottom left of the screen corresponds to coordinate (0, 0) and the top right of the screen corresponds to (Screen.width, Screen.height). Interpret the screen pose Depending on your target indicator manager's boundary configuration, the screen pose values can be interpreted differently. The following sections describe how to interpret the ScreenPose for different boundary types. Warning If you are using uGUI (Unity UI), the coordinates can be affected by the Canvas.renderMode. Refer to uGUI indicators to learn more about how to handle different render modes. Padded boundary type The ScreenPose.position.x and ScreenPose.position.y components correspond directly to screen coordinates. This means you should place your UI indicator at those exact coordiantes. The ScreenPose.position.z component corresponds to the depth from the camera the target is in world space. This can be helpful to know if a target is behind you. It is not needed for placing UI indicators on the screen. The ScreenPose.rotation property indicates the direction to rotate towards the target in screen space from the right vector (1, 0). This is useful if you want to have an arrow pointing at the target in screen space when the target is outside the boundary. Refer to the image below to understand how rotations apply to target indicators. This image shows the screen space coordinate system and the rotation of a target indicator. The indicator has a rotation of 130° relative to the right vector (1, 0) in screen space. Use this value to rotate an arrow to point at the target. The vector in screen space that the rotation of a screen pose is relative to. The vector pointing to the target indicators screen pose. This is the vector used to calculate the angle. Absolute boundary type Like the padded boundary type, the absolute boundary uses the ScreenPose.position and ScreenPose.rotation the same. Compass tape boundary type Unlike the Padded and Absolute boundary types, the CompassTape boundary type does not provide direct pixel screen coordinates. Instead, TargetIndicator.ScreenPose.x contains a normalized value between 0 and 1, representing the target's horizontal position on the tape. All other ScreenPose components will be 0. The screen pose rotation will be Quaternion.identity. Compass tape primer Compass tapes are compasses that are displayed as a horizontal strip with a scrolling texture as the user turns around the Y, or up, axis and the middle of the compass always corresponds to the direction the user is facing. Compass tapes are broken up into two parts: Full tape Full tape is the part of the compass tape that reprsents the full spectrum of cardinal directions north, east, south, and west. It is the distance for one full rotation. The full tape is not always visible as it requires a texture to scroll and wrap around the tape as the user makes a full rotation. Visible tape Visible tape refers to the part of the compass tape that is visible at any given time and is shorter than the full tape length. Often the visible tape is half the length of the full tape. Refer to the image below to understand how the screen pose for a compass tape is mapped to a compass tape. This image represents looking down onto a player on the XZ plane of the world. The point where the user is standing facing the positive Z axis. The point directly behind the player that corresponds to 0, or the left end of the full tape. The values increase around the circle in a clockwise rotation. The point directly in front of the player that corresponds to 0.5, or half way across the full tape. The point also directly behind the player that corresponds to 1, or the right end of the full tape. This is the highest value on the compass tape and rotating clockwise beyond this point will wrap the value back to 0. The point of a tracked target in front of and to the left of the player. The value will be ≈ 0.3, or about one third from the left end of the full tape represented by the matching green circles. The left end of the full tape. The left end of the visible tape. The right end of the visible tape. The right end of the full tape. A target that is directly in front of the player will have a ScreenPose.position.x value of 0.5. As the target moves around the player in a clockwise rotation, its value will increase to 1 as it reaches directly behind the player. If the target continues to move in a clockwise rotation from behind the player, its value will wrap to 0 and increase back to 0.5 as it reached to its starting point directly in front of the player. You can use this 0 to 1 value to know where on your full tape the indicator should be placed. Unbounded boundary type Similar to Padded and Absolute boundary types, Unbounded uses direct pixel screen coordinates. However, when a target moves outside the camera's field of view, its corresponding visual indicator will also move off-screen, as it is not clamped to the screen edges. When a target rotates behind the player, resulting in TargetIndicator.ScreenPose.position.z becoming less than 0, the system sets TargetIndicator.ScreenPose.position.x to float.MaxValue. This ensures visual indicators do not incorrectly appear on screen when their target is behind the player."
  },
  "manual/user_guide/ugui-indicators.html": {
    "href": "manual/user_guide/ugui-indicators.html",
    "title": "uGUI indicators | Target Indicators Documentation",
    "summary": "uGUI indicators A TargetIndicator is a C# struct containing screen-space data, not a visual element. To display this data, you must create your own visual indicator. Building visual indicators with Unity UI requires understanding the RectTransform system, specifically the relationship between a visual indicator's RectTransform and its parent's RectTransform. Visual Indicator Parent RectTransform The RectTransform of a visual indicator's parent significantly influences how indicators are positioned on the screen, particularly due to its anchors, size, and pivot. To ensure a target's ScreenPose.position directly corresponds to the anchoredPosition of a child visual indicator, the parent RectTransform should have its anchorMin set to (0, 0) and its anchorMax set to (1, 1). This configuration ensures the visual indicators reposition correctly regardless of the parent's pivot or size, and adapts to screen size changes. Visual Indicator RectTransform To position a visual indicator's RectTransform at a target's screen pose, assign the TargetIndicator.ScreenPose.position value to RectTransform.anchoredPosition. For the visual indicator to be perfectly centered on the target's screen pose, set its anchorMin, anchorMax, and pivot properties to (0.5, 0.5). If you need to offset a visual indicator from the target's precise screen pose, for example to place an arrow tip at the coordinate, create a child GameObject for the offset and parent the visual content to it. By applying the TargetIndicator.ScreenPose.position directly to the main visual indicator RectTransform, the desired offset will be maintained through the GameObject hierarchy. Canvas render mode For consistent and reliable results, use the Screen Space - Overlay Canvas Render Mode. This ensures visual indicators are always drawn on top of the 3D environment, preventing occlusion. If you use Screen Space - Camera and assign a camera, visual indicators can be occluded by scene geometry. This occurs if the Canvas's plane distance places it behind objects in the camera's view. Important Changing the CanvasScaler.uiScaleMode can alter the Canvas's scale, which affects how screen coordinates are interpreted. When applying TargetIndicator screen poses to your visual indicators, ensure you account for the Canvas's current scale. For instance, if the Canvas's scale factor is 0.5, you must double the TargetIndicator screen pose values to achieve correct placement."
  },
  "manual/user_guide/ugui.html": {
    "href": "manual/user_guide/ugui.html",
    "title": "uGUI indicators | Target Indicators Documentation",
    "summary": "uGUI indicators This page describes how to use target indicators with Unity UI. Remember that a TargetIndicator is only a C# struct and you need to create your own visualizer known as a UI indicator. Building UI indicators with Unity UI relies on understanding how the RectTransform system works and the relationship between the UI indicators RectTransform its the parents RectTransform. UI Indicator RectTransform To set the position of a RectTransform, use RectTransform.anchoredPosition and assign the TargetIndicator.ScreenPose.position to it. To center the UI indicator on the screen pose of the target indicator, ensure the RectTransform.anchorMin, RectTransform.anchorMax, and RectTransform.pivot are set to 0.5. To offset an indicator from the screen pose you should create a child GameObject and use that to offset the UI indicator and its content. Then at runtime as you get target indicator's screen poses, you can apply them directly to the UI indicator and the offset will be baked into the GameObject hiarchy structure. UI Indicator Parent RectTransform The RectTransform the UI indicator is parented to can affect how your indicators are positioned on the screen depending on its anchors, size, and pivot. To ensure the screen pose corresponds directly to the anchored position of a UI indicator, the parent RectTransform should have its RectTransform.anchorMin set to (0, 0) and it's RectTransform.anchorMax to (1, 1). This ensures that regardless of the pivot and size of the RectTransform and any changes screen size, the UI indicators will reposition correctly. Canvas render mode For the most reliable results, use the Canvas render mode Screen Space - Overlay. This ensure that UI doesn't get occluded by the environment. If you set the render mode to Screen Space - Camera and assign a camera, UI indicators can can get occluded by geometry in the environment if the plane distance of the canvas is further than the geometry in the camera view. Important Changing the CanvasScalar.uiScaleMode can change the Canvas' scale. Be sure to account for the change in scale when applying target indicator screen poses to UI indicators. If the Canvas scale is 0.5 you should double the values of the target indicators screen pose."
  },
  "manual/user_guide/xr-indicators.html": {
    "href": "manual/user_guide/xr-indicators.html",
    "title": "XR indicators | Target Indicators Documentation",
    "summary": "XR indicators A common challenge in XR applications is effectively guiding users to important off-screen items or locations within their virtual environment. Target Indicators can provide this guidance by directing users towards targets in their environment. This specific approach for XR has particular configuration requirements. Configure target indicators for XR The following steps outline how to set up your scene: Set your BoundaryType to Absolute. Adjust the Width and Height properties to define your boundary size. Display your visual indicators on a Canvas configured to Screen Space - Camera render mode. Tip When using Screen Space - Camera, visual indicators can be occluded by scene geometry. To minimize this, adjust the Canvas's Plane Distance to be closer to the camera, or consider using an overlay shader that forces the UI to draw on top of all scene geometry. Current limitations While usable, the current screen-space solution for XR has some limitations: Screen Space UI - The package currently relies on screen-space UI. While Screen Space - Camera is used, true world-space UI, which is generally recommended for XR applications to provide a more immersive and stable experience, is not directly supported. Jitter and Shaking: Due to the nature of converting world-space targets to screen space, visual indicators may appear shaky or jittery on the display, particularly during small head movements or vibrations of the XR headset. This can detract from user comfort and visual stability. I'm open to developing a more robust, XR-centric solution if there is sufficient demand from the community. Please reach out if this is a feature you would like to see improved."
  }
}