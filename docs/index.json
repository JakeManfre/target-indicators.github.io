{
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | Target Indicators Documentation",
    "summary": "Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning. [Unreleased] Added Changed Deprecated Removed Fixed"
  },
  "api/TargetIndicators.BoundaryShape.html": {
    "href": "api/TargetIndicators.BoundaryShape.html",
    "title": "Enum BoundaryShape | Target Indicators Documentation",
    "summary": "Enum BoundaryShape Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public enum BoundaryShape Fields Name Description Ellipse Rectangle"
  },
  "api/TargetIndicators.BoundaryType.html": {
    "href": "api/TargetIndicators.BoundaryType.html",
    "title": "Enum BoundaryType | Target Indicators Documentation",
    "summary": "Enum BoundaryType Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public enum BoundaryType Fields Name Description Absolute CompassTape Padded Unbounded"
  },
  "api/TargetIndicators.Ellipse.html": {
    "href": "api/TargetIndicators.Ellipse.html",
    "title": "Struct Ellipse | Target Indicators Documentation",
    "summary": "Struct Ellipse Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public struct Ellipse Constructors Ellipse(Vector2, float, float) Declaration public Ellipse(Vector2 center, float semiMajorAxisLength, float semiMinorAxisLength) Parameters Type Name Description Vector2 center float semiMajorAxisLength float semiMinorAxisLength Properties Center Declaration public readonly Vector2 Center { get; } Property Value Type Description Vector2 SemiMajorAxisLength Declaration public readonly float SemiMajorAxisLength { get; } Property Value Type Description float SemiMinorAxisLength Declaration public readonly float SemiMinorAxisLength { get; } Property Value Type Description float"
  },
  "api/TargetIndicators.TargetIndicator.html": {
    "href": "api/TargetIndicators.TargetIndicator.html",
    "title": "Struct TargetIndicator | Target Indicators Documentation",
    "summary": "Struct TargetIndicator Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public struct TargetIndicator Constructors TargetIndicator(TargetIndicatorId, Transform, Pose, bool) Declaration public TargetIndicator(TargetIndicatorId id, Transform target, Pose screenPose, bool isOutsideBounds) Parameters Type Name Description TargetIndicatorId id Transform target Pose screenPose bool isOutsideBounds TargetIndicator(TargetIndicatorId, Transform, Vector3, Quaternion, bool) Declaration public TargetIndicator(TargetIndicatorId id, Transform target, Vector3 screenPoint, Quaternion rotation, bool isOutsideBounds) Parameters Type Name Description TargetIndicatorId id Transform target Vector3 screenPoint Quaternion rotation bool isOutsideBounds Properties Default Declaration public static TargetIndicator Default { get; } Property Value Type Description TargetIndicator Id Declaration public readonly TargetIndicatorId Id { get; } Property Value Type Description TargetIndicatorId IsOutsideBounds Declaration public readonly bool IsOutsideBounds { get; } Property Value Type Description bool ScreenPose Declaration public readonly Pose ScreenPose { get; } Property Value Type Description Pose Target Declaration public readonly Transform Target { get; } Property Value Type Description Transform"
  },
  "api/TargetIndicators.TargetIndicatorBoundaryVisualizer.html": {
    "href": "api/TargetIndicators.TargetIndicatorBoundaryVisualizer.html",
    "title": "Class TargetIndicatorBoundaryVisualizer | Target Indicators Documentation",
    "summary": "Class TargetIndicatorBoundaryVisualizer Inheritance object TargetIndicatorBoundaryVisualizer Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public class TargetIndicatorBoundaryVisualizer : MonoBehaviour Constructors TargetIndicatorBoundaryVisualizer() Declaration public TargetIndicatorBoundaryVisualizer()"
  },
  "api/TargetIndicators.TargetIndicatorId.html": {
    "href": "api/TargetIndicators.TargetIndicatorId.html",
    "title": "Struct TargetIndicatorId | Target Indicators Documentation",
    "summary": "Struct TargetIndicatorId Implements IEquatable<TargetIndicatorId> Inherited Members ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public readonly struct TargetIndicatorId : IEquatable<TargetIndicatorId> Constructors TargetIndicatorId(Guid) Declaration public TargetIndicatorId(Guid id) Parameters Type Name Description Guid id Properties Default Declaration public static TargetIndicatorId Default { get; } Property Value Type Description TargetIndicatorId Id Declaration public Guid Id { get; } Property Value Type Description Guid Methods Equals(object) Declaration public override bool Equals(object obj) Parameters Type Name Description object obj Returns Type Description bool Overrides ValueType.Equals(object) Equals(TargetIndicatorId) Declaration public bool Equals(TargetIndicatorId other) Parameters Type Name Description TargetIndicatorId other Returns Type Description bool GetHashCode() Declaration public override int GetHashCode() Returns Type Description int Overrides ValueType.GetHashCode() Operators operator ==(TargetIndicatorId, TargetIndicatorId) Declaration public static bool operator ==(TargetIndicatorId a, TargetIndicatorId b) Parameters Type Name Description TargetIndicatorId a TargetIndicatorId b Returns Type Description bool operator !=(TargetIndicatorId, TargetIndicatorId) Declaration public static bool operator !=(TargetIndicatorId a, TargetIndicatorId b) Parameters Type Name Description TargetIndicatorId a TargetIndicatorId b Returns Type Description bool Implements IEquatable<T>"
  },
  "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsRemovedDelegate.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsRemovedDelegate.html",
    "title": "Delegate TargetIndicatorManager.TargetIndicatorsRemovedDelegate | Target Indicators Documentation",
    "summary": "Delegate TargetIndicatorManager.TargetIndicatorsRemovedDelegate Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public delegate void TargetIndicatorManager.TargetIndicatorsRemovedDelegate(ReadOnlySpan<TargetIndicatorId> span) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span Constructors TargetIndicatorsRemovedDelegate(object, nint) Declaration public TargetIndicatorsRemovedDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods BeginInvoke(ReadOnlySpan<TargetIndicatorId>, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ReadOnlySpan<TargetIndicatorId> span, AsyncCallback callback, object @object) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Invoke(ReadOnlySpan<TargetIndicatorId>) Declaration public virtual void Invoke(ReadOnlySpan<TargetIndicatorId> span) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span"
  },
  "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsUpdatedDelegate.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsUpdatedDelegate.html",
    "title": "Delegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate | Target Indicators Documentation",
    "summary": "Delegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public delegate void TargetIndicatorManager.TargetIndicatorsUpdatedDelegate(ReadOnlySpan<TargetIndicator> span) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span Constructors TargetIndicatorsUpdatedDelegate(object, nint) Declaration public TargetIndicatorsUpdatedDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods BeginInvoke(ReadOnlySpan<TargetIndicator>, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ReadOnlySpan<TargetIndicator> span, AsyncCallback callback, object @object) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Invoke(ReadOnlySpan<TargetIndicator>) Declaration public virtual void Invoke(ReadOnlySpan<TargetIndicator> span) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span"
  },
  "api/TargetIndicators.TargetIndicatorManager.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.html",
    "title": "Class TargetIndicatorManager | Target Indicators Documentation",
    "summary": "Class TargetIndicatorManager Inheritance object TargetIndicatorManager Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public class TargetIndicatorManager : MonoBehaviour Constructors TargetIndicatorManager() Declaration public TargetIndicatorManager() Properties BottomPadding Declaration public float BottomPadding { get; set; } Property Value Type Description float BoundaryShape Declaration public BoundaryShape BoundaryShape { get; set; } Property Value Type Description BoundaryShape BoundaryType Declaration public BoundaryType BoundaryType { get; set; } Property Value Type Description BoundaryType Camera Declaration public Camera Camera { get; set; } Property Value Type Description Camera Ellipse Declaration public Ellipse Ellipse { get; } Property Value Type Description Ellipse Height Declaration public float Height { get; set; } Property Value Type Description float LeftPadding Declaration public float LeftPadding { get; set; } Property Value Type Description float MaxTargets Declaration public int MaxTargets { get; } Property Value Type Description int Rectangle Declaration public Rect Rectangle { get; } Property Value Type Description Rect RightPadding Declaration public float RightPadding { get; set; } Property Value Type Description float TopPadding Declaration public float TopPadding { get; set; } Property Value Type Description float TrackedTargetsCount Declaration public int TrackedTargetsCount { get; } Property Value Type Description int Width Declaration public float Width { get; set; } Property Value Type Description float Methods GetScreenPose(in Vector3, out bool) Declaration public Pose GetScreenPose(in Vector3 worldSpacePosition, out bool isOutsideBounds) Parameters Type Name Description Vector3 worldSpacePosition bool isOutsideBounds Returns Type Description Pose IsOutsideBounds(in Vector3) Declaration public bool IsOutsideBounds(in Vector3 screenPoint) Parameters Type Name Description Vector3 screenPoint Returns Type Description bool RemoveAllTargets() Declaration public void RemoveAllTargets() TryAddTarget(Transform, out TargetIndicator) Declaration public bool TryAddTarget(Transform target, out TargetIndicator targetIndicator) Parameters Type Name Description Transform target TargetIndicator targetIndicator Returns Type Description bool TryGetTargetIndicator(TargetIndicatorId, out TargetIndicator) Declaration public bool TryGetTargetIndicator(TargetIndicatorId targetIndicatorId, out TargetIndicator targetIndicator) Parameters Type Name Description TargetIndicatorId targetIndicatorId TargetIndicator targetIndicator Returns Type Description bool TryRemoveTarget(TargetIndicatorId) Declaration public bool TryRemoveTarget(TargetIndicatorId targetIndicatorId) Parameters Type Name Description TargetIndicatorId targetIndicatorId Returns Type Description bool Events TargetIndicatorsAdded Declaration public event TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsAdded Event Type Type Description TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsRemoved Declaration public event TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorsRemoved Event Type Type Description TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorsUpdated Declaration public event TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsUpdated Event Type Type Description TargetIndicatorManager.TargetIndicatorsUpdatedDelegate"
  },
  "api/TargetIndicators.html": {
    "href": "api/TargetIndicators.html",
    "title": "Namespace TargetIndicators | Target Indicators Documentation",
    "summary": "Namespace TargetIndicators Classes TargetIndicatorBoundaryVisualizer TargetIndicatorManager Structs Ellipse TargetIndicator TargetIndicatorId Enums BoundaryShape BoundaryType Delegates TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate"
  },
  "get-target-indicators.html": {
    "href": "get-target-indicators.html",
    "title": "",
    "summary": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "summary": ""
  },
  "introduction.html": {
    "href": "introduction.html",
    "title": "Introduction | Target Indicators Documentation",
    "summary": "Introduction"
  },
  "manual/guide/overview.html": {
    "href": "manual/guide/overview.html",
    "title": "Overview | Target Indicators Documentation",
    "summary": "Overview Target indicators are fundamentally screen coordintes in pixels that represent the projection of a 3D position in world space. Target indicators can be configured to be bound by the edges of the screen so that they are always visible and indicate the closest direction to a target. This is useful in games or apps where you want to show users where to go or where to look that is difficult to find or not in view of the camera. Target indicators also provides additional information that can provide more context of a target such as the rotation needed to point an arrow at a target or whether the target is outside a configured boundary of the screen. For example you can have a target indicator mark an important object and when the object moves off screen the indicator enables an arrow that rotates as the indicator stays bound to the screen to show exactly where the object is. Main components The target indicator system is comprised of two main components. Target Indicator Manager The target indicator manager is responsible for managing all of the tracked targets and calculating the data necessary for displaying an indicator on the screen. It can manage its own life cycle events for you to be notified when indicators change or it can be used to get screen pose data for targets with your own life cycle control. The target indicator manager can be used with any UI system because it only manages the conversion between world space positions and screen space positions. There are configurable options offered by the target indicator manager to control what type of boundary you want, it's shape, and it's size so you can customize the boundary for your apps needs. To learn more about how to use the target indicator manager and it's capabilities refer to Target Indicator Manager. Tip The Target Indicators package offers Samples that provides prefabs using uGUI that you can customize for your project's needs if you don't want to build your own indicator visualizers. Target Indicator The data generated by the target indicator manager that represents the screen space information to visualize target indicators is known as a TargetIndicator. While referred to as a component in the context of the design, a target indicator is not a component in the Unity sense that it can be attached to GameObjects. A target indicator is a struct that contains relevent information about a tracked target such as the screen pose for the coordinates to place indicators in your UI. To learn more about how to use target indicators created by the target indicator manager, refer to Target Indicator."
  },
  "manual/guide/target-indicator-manager.html": {
    "href": "manual/guide/target-indicator-manager.html",
    "title": "Target Indicator Manager | Target Indicators Documentation",
    "summary": "Target Indicator Manager Target Indicators only requires the TargetIndicatorManager component which is responsible for handling added, updated, and removed targets to track. The following sections explain how to use the target indicator manager. Important By default Target Indicators does not display or draw any UI in the scene. It only returns screen coordinates for you to display your own indicators. This enables you to use any UI system you want. If you are interested in a prebuilt indicator UI you can import the sample's starter assets which provides a solution with Unity UI. Refer to the samples docs to learn more about how to configure the prebuilt indicators. Scene Setup Add the TargetIndicatorManager to a GameObject in the hiearchy and edit the configuration to your projects needs. Configure the Target Indicator Manager The TargetIndicatorManager has several properties that can be edited within the inspector or set at runtime. The following sections explains each property in more detail. Camera The camera is used for calculating the screen space coordinates of each target. By default, when the TargetIndicatorManager component is added or reset it will assign the camera in your scene with the MainCamera tag. If no camera has the MainCamera tag it will fallback to using the first camera in the scene. Assign the camera that you will be using to display target indicators. To assign the camera reference at runtime, use TargetIndicatorManager.Camera. Boundary type The boundary type determines how target indicators should be bounded to the screen if the target moves outside of the boundary. For example indicators can be bound by the screen edges and automatically adjust to changes in screen size or they can have no boundary and only show an indicator when the target is on screen. To assign or change the boundary type at runtime, use TargetIndicatorManager.BoundaryType. There are four boundary types: Padded The padded boundary type bounds target indicators to the screen edges with adjustable padding. The boundary will dynamically update if the screen changes size. Padded boundary is common for indicating waypoints, enemies, and points of interest. Absolute The absolute boundary type bounds target indicators to the screen with a fixed size. It will not change if the screen size changes. Absolute boundary is common in first person games where you want to indicate the direction a player or other character is attacking from when not directly in front of the user. Compass Tape The compass tape boundary bounds targets to a horizontal compass referred to as a compass tape. Unlike the other boundary types, compass tape does not provide screen coordinates. Instead it provides a value between 0 and 1 for the TargetIndicator.ScreenPose.x component. To learn more about how to use the screen pose for a target indicator on a compass tape refer to target indicators with compass tape. Refer to the Samples for an example of how to use compass tape. Unbounded The unbounded boundary type does not bound target indicators at all and they always stick to the screen pose of the target. This means if the target goes off screen, the target indicator will also go off screen. Boundary shape When using Padded or Absolute boundary types, configure the shape of the boundary with the BoundaryShape property. There are two boundary shapes: Rectangle TargetIndicatorManager.Ellipse represents the rectangle data generated by the currnet configuration. Ellipse TargetIndicatorManager.Ellipse represents the ellipse data generated by the current configuration. Padding When BoundaryType is Padded you can adjust the distance in pixels between the edge of the screen and the boundary. You can configure the padding for the Top, Bottom, Left, and Right edges independently. These properties are ignored if the boundary shape is not set to Padded. Size When BoundaryType is Absolute you can adjust the size by the Width and Height properties. The size does not change if the screen size changes. These properties are ignored if the boundary shape is not set to Absolute. Visualize the boundary You can visualize your current configuration at edit time and at runtime with the TargetIndicatorBoundaryVisualizer component. The following sections describe how to use the TargetIndicatorBoundaryVisualizer to visualize the configured boundary. Add visualizer Attach the TargetIndicatorBoundaryVisualizer component by clicking the Add Boundary Visualizer button on the bottom of the target indicator manager component. Once added, you can remove the visualizer by clicking the Remove Boundary Visualizer. Note Not all boundary types can be visualized. Only BoundaryType.Padded and BoundaryType.Absolute can be visualized. Edit visualizer Boundary line color and line width properties are available in the inspector to modify the boundary visualizer. This is useful if you have multiple target indicator managers and need to distinguish easily between them. API The following sections describe how to use the target indicator manager API. Add a target To add a target to track use TryAddTarget as shown in the following code example: public void TryAddTargetExample(TargetIndicatorManager manager, Transform target) { var wasAdded = manager.TryAddTarget(target, out var targetIndicator); if (!wasAdded) { // Failed to add target because max limit of targets is reached. // Handle error. return; } // Successfully added target. } The max number of targets that can be tracked at once is 100. TryAddTarget can only fail if you try to add more than 100 targets. To get the current number of tracked targets use TrackedTargetsCount. If you need more than 100 (god bless), you can use multiple target indicator managers. Keep track of the returned TargetIndicator.TrackedIndicatorId in the out parameter to know which target indicator corresponds to a target. Remove a target To remove a target from being tracked use TryRemoveTarget as shown in the following code example: public void TryRemoveTargetExample(TargetIndicatorManager manager, TargetIndicatorId id) { var wasRemoved = manager.TryRemoveTarget(id); if (!wasRemoved) { // Failed to remove target because the target indicator ID was invalid. // Handle error. return; } // Successfully removed target. } Removing a target can only fail if you pass an invalid TargetIndicatorId. Remove all targets To remove all targets at once use RemoveAllTargets as shown in the following code example: public void RemoveAllTargetsExample(TargetIndicatorManager manager) { manager.RemoveAllTargets(); // Successfully removed all tracked targets. } Tip If you just want to stop receiving updates you can disable the TargetIndicatorManager component. Re-enabling it will resume tracking targets. Get a target To check if a target indicator is being tracked use TryGetTargetIndicator as shown in the following code example: public void GetATargetIndicatorExample( TargetIndicatorManager manager, TargetIndicatorId id) { var didGet = manager.TryGetTargetIndicator(id, out var targetIndicator); if (!didGet) { // Failed to get target because target indicator ID was invalid. // Handle error. return; } // Successfully received target indicator. } Get screen pose If you want to get the screen pose of any world space position that adherers to you current boundary configuration, use GetScreenPose. This can be useful if you want to control your own life cycle, or if you only need a one time update, or you need infrequent updates for a targets screen pose. The following code example shows you how to use GetScreenPose: public void GetScreenPoseExample( TargetIndicatorManager manager, Vector3 worldSpacePosition) { var screenPose = manager.GetScreenPose(worldSpacePosition, out var isOutsideBounds); // screenPose.position.x = horizontal axis coordinate in screen space (pixels). // screenPose.position.y = vertical axis coordinate in screen space (pixels). // screenPose.position.z = depth from the camera in world space (meters). // screenPose.rotation = direction to target in screen space. // isOutsideBounds = true if the screenPose.position is outside the configured bounds. // The depth from the camera is ignored in this check. } Is outside boundary Each TargetIndicator contains an IsOutsideBoundary property that you can use to know if a target indicators is outside the bounds of the current configuration when the TargetIndicator was created. If you want to know if any Vector3 position is outside the current boundary configuration use TargetIndicatorManager.IsOutsideBoundary as shown in the following example: public void IsOutsideBoundaryExample( TargetIndicatorManager manager, Vector3 worldSpacePosition) { var isOutsideBounds = manager.IsOutsideBounds(worldSpacePosition); // isOutsideBounds = true if the screen pose coordinates are outside the // configured bounds. The depth from the camera is ignored in this check. } Important For BoundaryType.CompassTape and BoundaryType.Unbounded the IsOutsideBoundary property will always be false. BoundaryType.Compas requires knowledge about your specific compass tape setup to determine if it's outside the boundary.sTape Refer to samples as a reference for how you can check if the target indicator is outside of the boundary. Life cycle events While enabled, the TargetIndicatorManager component will check for changes every frame. If any anchors were added, updated, or removed, TargetIndicatorManager will invoke TargetIndicatorsAdded, TargetIndicatorsUpdated, TargetIndicatorsRemoved events respectively. Each event passes a ReadOnlySpan that wraps around an underlying array. This avoids heap allocations and slices the array to the size of changes that occurred since the last time the events were invoked. The following code example shows how you can subscribe to these events and iterate over the spans they pass: public void LifeCycleExample(TargetIndicatorManager manager) { manager.TargetIndicatorsAdded += OnTargetIndicatorsAdded; manager.TargetIndicatorsUpdated += OnTargetIndicatorsUpdated; manager.TargetIndicatorsRemoved += OnTargetIndicatorsRemoved; } void OnTargetIndicatorsAdded(ReadOnlySpan<TargetIndicator> added) { foreach (var targetIndicator in added) { var screenPose = targetIndicator.ScreenPose; } } void OnTargetIndicatorsUpdated(ReadOnlySpan<TargetIndicator> updated) { foreach (var targetIndicator in updated) { var updatedScreenPose = targetIndicator.ScreenPose; } } void OnTargetIndicatorsRemoved(ReadOnlySpan<TargetIndicatorId> removed) { foreach (var targetIndicatorId in removed) { // TargetIndicatorId was removed. } } You can disable the TargetIndicatorManager component to stop receiving life cycle events and control your own life cycle and rely on the TargetIndicatorManager exclusively for pose and boundary checks. Using multiple target indicator managers Some applications might require multiple boundary types or multiple configurations. You can have multiple TargetIndicatorManager components in your scene to get more complex designs. For example if you use BoundaryType.CompassTape you will only get indicators to display on the compass tape but might not know what target they correspond to. You can have a second TargetIndicatorManager that is configured to use BoundaryType.Unbounded that marks the same target with a matching icon as used in your compass tape visualizer to indicate which target represents which marker in your compass tape indicator. The Samples provides an example of how to configre multiple target indicator managers."
  },
  "manual/guide/target-indicator.html": {
    "href": "manual/guide/target-indicator.html",
    "title": "Target Indicator | Target Indicators Documentation",
    "summary": "Target Indicator A Target Indicator is a C# struct that contains the properties necessary for placing indicators on the screen to track a target. The following sections explains the target indicator properties and how they map to the screen in more detail. Target indicator id The TargetIndicatorId property is the unique ID associated with a target indicator. It is generated by the Target indicator manager for each target and persists until the target is removed from the target indicator manager. If a target is added back to the target indicator manager after it has been removed, it will have a new target indicator ID. Target The target is the transform that the target indicator is tracking. The position of the target is what gets transformed to the screen coordinates for the target indicator. Screen pose The ScreenPose property is a Pose that contains the position and rotation of the target indicator for placement of a UI indicator. The values stored in the position and rotation of the pose differ between the boundary type when the target indicator was created. Refer to interpret the screen pose to learn how to use the respective pose values. Is outside boundary The IsOutsideBoundary property indicates if the screen pose of the target is outside of the boundary configured by the target indicator manager when the target indicator was created. The IsOutsideBoundary property will not update on existing target indicators structs if the boundary changes. You should get a new target indicator for the target after an update to get the updated state or use TargetIndicatorManager.IsOutsideBoundary. Important For BoundaryType.CompassTape and BoundaryType.Unbounded the IsOutsideBoundary property will always be false. BoundaryType.Compas requires knowledge about your specific compass tape setup to determine if it's outside the boundary.sTape Refer to samples as a reference for how you can check if the target indicator is outside of the boundary. Screen coordinates Target indicators uses screen coordinates in pixels to describe the placement of a target indicator. The bottom left of the screen corresponds to coordinate (0, 0) and the top right of the screen corresponds to (Screen.width, Screen.height). Interpret the screen pose Depending on your target indicator manager's boundary configuration, the screen pose values can be interpreted differently. The following sections describe how to interpret the ScreenPose for different boundary types. Warning If you are using uGUI (Unity UI), the coordinates can be affected by the Canvas.renderMode. Refer to uGUI indicators to learn more about how to handle different render modes. Padded boundary type The ScreenPose.position.x and ScreenPose.position.y components correspond directly to screen coordinates. This means you should place your UI indicator at those exact coordiantes. The ScreenPose.position.z component corresponds to the depth from the camera the target is in world space. This can be helpful to know if a target is behind you. It is not needed for placing UI indicators on the screen. The ScreenPose.rotation property indicates the direction to rotate towards the target in screen space from the right vector (1, 0). This is useful if you want to have an arrow pointing at the target in screen space when the target is outside the boundary. Refer to the image below to understand how rotations apply to target indicators. This image shows the screen space coordinate system and the rotation of a target indicator. An indicator with a rotation of 130° relative to the right vector (1, 0) in screen space. The vector in screen space that the rotation of a screen pose is relative to. The vector pointing to the target indicators screen pose. This is the vector used to calculate the angle. Absolute boundary type Like the padded boundary type, the absolute boundary uses the ScreenPose.position and ScreenPose.rotation the same. Compass tape boundary type Unlike padded and absolute boundary types, the compass tape boundary type does not use screen coordinates directly. Instead, ScreenPose.position.x stores a values between 0 and 1 while the rest of the position components will always be 0. Compass tape primer Compass tapes are compasses that are displayed as a horizontal strip with a scrolling texture as the user turns around the Y, or up, axis and the middle of the compass always corresponds to the direction the user is facing. Compass tapes are broken up into two parts: Full tape Full tape is the part of the compass tape that reprsents the full spectrum of cardinal directions north, east, south, and west. It is the distance for one full rotation. The full tape is not always visible as it requires a texture to scroll and wrap around the tape as the user makes a full rotation. Visible tape Visible tape refers to the part of the compass tape that is visible at any given time and is shorter than the full tape length. Often the visible tape is half the length of the full tape. Refer to the image below to understand how the screen pose for a compass tape is mapped to a compass tape. This image represents looking down onto a player on the XZ plane of the world. The point where the user is standing facing the positive Z axis. The point directly behind the player that corresponds to 0, or the left end of the full tape. The values increase around the circle in a clockwise rotation. The point directly in front of the player that corresponds to 0.5, or half way across the full tape. The point also directly behind the player that corresponds to 1, or the right end of the full tape. This is the highest value on the compass tape and rotating clockwise beyond this point will wrap the value back to 0. The point of a tracked target in front of and to the left of the player. The value will be ≈ 0.3, or about one third from the left end of the full tape represented by the matching green circles. The left end of the full tape. The left end of the visible tape. The right end of the visible tape. The right end of the full tape. A target that is directly in front of the player will have a ScreenPose.position.x value of 0.5. As the target moves around the player in a clockwise rotation, its value will increase to 1 as it reaches directly behind the player. If the target continues to move in a clockwise rotation from behind the player, its value will wrap to 0 and increase back to 0.5 as it reached to its starting point directly in front of the player. You can use this 0 to 1 value to know where on your full tape the indicator should be placed. Unbounded boundary type Similar to padded and absolute, unbounded boundary type uses direct screen coordinates. However as the target exits the field of view, it will not be bound by the edges of the screen and the placement of any UI indicator will be off screen. As the target continues to rotate around a player, if it move behind the player, having a ScreenPose.position.z < 0, it sets the ScreenPose.position.x to float.MaxValue. This prevents the indicator coming into view when the target is directly behind the player as the raw Camera.WorldToScreenPoint returns."
  },
  "manual/guide/ugui.html": {
    "href": "manual/guide/ugui.html",
    "title": "Target indicators with uGUI (Unity UI) | Target Indicators Documentation",
    "summary": "Target indicators with uGUI (Unity UI) This page describes how to use target indicators with Unity UI."
  },
  "manual/guide/xr.html": {
    "href": "manual/guide/xr.html",
    "title": "Target indicators in XR | Target Indicators Documentation",
    "summary": "Target indicators in XR This page describes how to use target indicators in XR. A common problem in XR is showing users where to look to find an important item or location in your app. You can configure your target indicators manager to guide users to targets in their environment. The current solution is limited and requires a specific configuration and setup. The following steps demonstrate how to setup your scene for XR: Set your boundary type to Absolute Edit the Width and Height Display you target indicators on a Canvas set to Screen Space Camera or UI system of your choice The Samples provides an example of how to use UGui for XR."
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Target Indicators | Target Indicators Documentation",
    "summary": "Target Indicators Target Indicators is a Unity package that enables you to create visual indicators to track targets. Use target indicators to guide users to points of interest, waypoints, other players, or any other 3D point. Customize your indicators to your project's needs. Works with any UI system by providing an API to get the bounded screen pose of any target. Included are Samples that can be used as a drag and drop system for a low code solution or used as a reference for building your own UI indicators. Note Get Target Indicators on the Unity Asset Store. Features Target indicators focuses on simplicity with high performance. The following features are what you can expect from this package: Works with any UI system* Highly configurable at edit and runtime No heap allocations after initialization Does not rely on Object.Find or any variations of scene searching at runtime Does not rely on GetComponent Simple and minmal samples scenes Works with traditional displays and XR HMDs Note *The package has a dependency on com.unity.ugui to support the samples and demo scenes. Dependencies The following dependencies are required for target indicators. Packages com.unity.inputsystem 1.14.0 for samples com.unity.ugui 2.0.0 for samples Unity version Unity 6000.0 or newer"
  },
  "manual/install-package.html": {
    "href": "manual/install-package.html",
    "title": "Install package | Target Indicators Documentation",
    "summary": "Install package Follow these steps to add the Target Indicators package to your project once you have purchased Target Indicators it on the Unity asset store: Open the package manager via Window > Package Management > Package Manager. In the package manager window navigate to My Assets and search for Target Indicators and click Download. After the packages has downloaded you should find the package contents in the Project Window > Packages > Target Indicators. Optional samples import If you want a premade indicator visualizer system using Unity UI you can import the Starter Assets: Navigate to Package Manager > In Project > Target Indicators > Samples and import the Starter Assets. After the starter assets have imported you can find them in Assets > Samples > Target Indicators > [version] > Starter Assets. Refer to the samples documentation to learn more."
  },
  "manual/samples/samples.html": {
    "href": "manual/samples/samples.html",
    "title": "Samples | Target Indicators Documentation",
    "summary": "Samples Coming soon."
  },
  "manual/user-guide.html": {
    "href": "manual/user-guide.html",
    "title": "User Guide | Target Indicators Documentation",
    "summary": "User Guide Refer to the following topics to understand target indicators and how to use them: Topic Description Overview Understand how target indicators work. Target Indicator Manager Understand how to configure and use the Target Indicator Manager component. Target Indicator Understand how to use target indicators created by the target indicator manager. uGUI indicators Understand how to configure target indicators for Unity UI. XR indicators Understand how to configure target indicators for XR."
  }
}