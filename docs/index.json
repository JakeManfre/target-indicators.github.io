{
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "Changelog | Target Indicators Documentation",
    "summary": "Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog, and this project adheres to Semantic Versioning."
  },
  "api/TargetIndicators.BoundaryShape.html": {
    "href": "api/TargetIndicators.BoundaryShape.html",
    "title": "Enum BoundaryShape | Target Indicators Documentation",
    "summary": "Enum BoundaryShape The shape of the boundary for Padded or Absolute boundary types that target indicators will clamp to. Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public enum BoundaryShape Fields Name Description Ellipse The boundary shape is an ellipse. Rectangle The boundary shape is a rectangle."
  },
  "api/TargetIndicators.BoundaryType.html": {
    "href": "api/TargetIndicators.BoundaryType.html",
    "title": "Enum BoundaryType | Target Indicators Documentation",
    "summary": "Enum BoundaryType The type of boundary that target indicators will clamp to. Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public enum BoundaryType Fields Name Description Absolute The boundary type is absolute where target indicators clamp relative to a defined size regardless of screen size. CompassTape The boundary type is compass tape where target indicators clamp between a value of 0 and 1. Padded The boundary type is padded where target indicators clamp relative to the screen edges with an adjustable padding. Unbounded The boundary type is unbounded and is not clamped at all."
  },
  "api/TargetIndicators.Ellipse.html": {
    "href": "api/TargetIndicators.Ellipse.html",
    "title": "Struct Ellipse | Target Indicators Documentation",
    "summary": "Struct Ellipse The data that defines the ellipse of the screen boundary. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public struct Ellipse Constructors Ellipse(Vector2, float, float) Constructs ellipse data by the center and axis lengths. This is provided by the TargetIndicatorManager. Declaration public Ellipse(Vector2 center, float semiMajorAxisLength, float semiMinorAxisLength) Parameters Type Name Description Vector2 center The coordinates of the center of the ellipse in screen space. float semiMajorAxisLength The length of the semi major axis, or half of the horizontal diameter. float semiMinorAxisLength The length of the semi minor axis, or half of the vertical diameter. Properties Center The coordinates of the center of the ellipse in screen space. Declaration public readonly Vector2 Center { get; } Property Value Type Description Vector2 SemiMajorAxisLength The length of the semi major axis, or half of the horizontal diameter. Declaration public readonly float SemiMajorAxisLength { get; } Property Value Type Description float SemiMinorAxisLength The length of the semi minor axis, or half of the vertical diameter. Declaration public readonly float SemiMinorAxisLength { get; } Property Value Type Description float"
  },
  "api/TargetIndicators.TargetIndicator.html": {
    "href": "api/TargetIndicators.TargetIndicator.html",
    "title": "Struct TargetIndicator | Target Indicators Documentation",
    "summary": "Struct TargetIndicator The contextual data that defines a tracked target in screen space. Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public struct TargetIndicator Constructors TargetIndicator(TargetIndicatorId, Transform, Pose, bool) Constructs a TargetIndicator. Declaration public TargetIndicator(TargetIndicatorId id, Transform target, Pose screenPose, bool isOutsideBoundary) Parameters Type Name Description TargetIndicatorId id The ID that defines the indicator. Transform target The target that is being tracked by the target indicator. Pose screenPose The screen space coordinates and rotation of the target. bool isOutsideBoundary The current state of the target's screen pose if it's outside the boundary. TargetIndicator(TargetIndicatorId, Transform, Vector3, Quaternion, bool) Constructs a TargetIndicator. Declaration public TargetIndicator(TargetIndicatorId id, Transform target, Vector3 screenPoint, Quaternion rotation, bool isOutsideBoundary) Parameters Type Name Description TargetIndicatorId id The ID that defines the indicator. Transform target The target that is being tracked by the target indicator. Vector3 screenPoint The screen space coordinates of the target. Quaternion rotation The screen space rotation of the target. bool isOutsideBoundary The current state of the target's screen pose if it's outside the boundary. Properties Default Gets a default-initialized TargetIndicator. This may be different from the zero-initialized version (for example, the pose is Pose.identity instead of zero initialized). Declaration public static TargetIndicator Default { get; } Property Value Type Description TargetIndicator Id The ID that defines the target indicator. Declaration public readonly TargetIndicatorId Id { get; } Property Value Type Description TargetIndicatorId IsOutsideBoundary True if the target's screen pose is outside the TargetIndicatorManager configured boundary. Otherwise, false. Declaration public readonly bool IsOutsideBoundary { get; } Property Value Type Description bool ScreenPose The screen space coordinates and rotation of the target. ScreenPose.position.x corresponds to the horizontal axis coordinate in pixels where 0 is the left end of the axis and UnityEngine.Screen.width is the right end of the axis. ScreenPose.position.y corresponds to the vertical axis coordinate in pixels where 0 is the bottom end of the axis and UnityEngine.Screen.height is the top end of the axis. ScreenPose.position.z corresponds to the depth from the camera in world space in meters. ScreenPose.rotation corresponds to the rotation in screen space relative to the right vector to rotate the indicator to point at the target. Declaration public readonly Pose ScreenPose { get; } Property Value Type Description Pose Target The target that is being tracked by the target indicator. Declaration public readonly Transform Target { get; } Property Value Type Description Transform"
  },
  "api/TargetIndicators.TargetIndicatorBoundaryVisualizer.html": {
    "href": "api/TargetIndicators.TargetIndicatorBoundaryVisualizer.html",
    "title": "Class TargetIndicatorBoundaryVisualizer | Target Indicators Documentation",
    "summary": "Class TargetIndicatorBoundaryVisualizer Visualizes the boundary configured in a TargetIndicatorManager. Note that BoundaryType.CompassTape and BoundaryType.Unbounded has no visualization. Inheritance object TargetIndicatorBoundaryVisualizer Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public class TargetIndicatorBoundaryVisualizer : MonoBehaviour Constructors TargetIndicatorBoundaryVisualizer() Declaration public TargetIndicatorBoundaryVisualizer()"
  },
  "api/TargetIndicators.TargetIndicatorId.html": {
    "href": "api/TargetIndicators.TargetIndicatorId.html",
    "title": "Struct TargetIndicatorId | Target Indicators Documentation",
    "summary": "Struct TargetIndicatorId The unique ID that represents a TargetIndicator. Implements IEquatable<TargetIndicatorId> Inherited Members ValueType.ToString() object.GetType() object.Equals(object, object) object.ReferenceEquals(object, object) Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public readonly struct TargetIndicatorId : IEquatable<TargetIndicatorId> Constructors TargetIndicatorId(Guid) constructs the TargetIndicatorId. Declaration public TargetIndicatorId(Guid id) Parameters Type Name Description Guid id Properties Id The underlying Guid that makes up the TargetIndicatorId. Declaration public Guid Id { get; } Property Value Type Description Guid Methods Equals(object) Tests for equality. Declaration public override bool Equals(object obj) Parameters Type Name Description object obj The object to compare. Returns Type Description bool true if they are equal, otherwise false. Overrides ValueType.Equals(object) Equals(TargetIndicatorId) Tests for equality. Declaration public bool Equals(TargetIndicatorId other) Parameters Type Name Description TargetIndicatorId other The TargetIndicatorId to compare. Returns Type Description bool true if they are equal, otherwise false. GetHashCode() Generates a hash code suitable for use in a Dictionary or Set. Declaration public override int GetHashCode() Returns Type Description int A hash code for participation in certain collections. Overrides ValueType.GetHashCode() Operators operator ==(TargetIndicatorId, TargetIndicatorId) Tests for equality. Declaration public static bool operator ==(TargetIndicatorId a, TargetIndicatorId b) Parameters Type Name Description TargetIndicatorId a The first TargetIndicatorId to compare. TargetIndicatorId b The second TargetIndicatorId to compare. Returns Type Description bool true if they are equal, otherwise false. operator !=(TargetIndicatorId, TargetIndicatorId) Tests for inequality. Declaration public static bool operator !=(TargetIndicatorId a, TargetIndicatorId b) Parameters Type Name Description TargetIndicatorId a The first TargetIndicatorId to compare. TargetIndicatorId b The second TargetIndicatorId to compare. Returns Type Description bool true if they are not equal, otherwise false. Implements IEquatable<T>"
  },
  "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsRemovedDelegate.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsRemovedDelegate.html",
    "title": "Delegate TargetIndicatorManager.TargetIndicatorsRemovedDelegate | Target Indicators Documentation",
    "summary": "Delegate TargetIndicatorManager.TargetIndicatorsRemovedDelegate Delegate that passes a ReadOnlySpan of target indicators that were removed. Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public delegate void TargetIndicatorManager.TargetIndicatorsRemovedDelegate(ReadOnlySpan<TargetIndicatorId> span) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span Delegate that passes a ReadOnlySpan of target indicators that were removed. Constructors TargetIndicatorsRemovedDelegate(object, nint) Declaration public TargetIndicatorsRemovedDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods BeginInvoke(ReadOnlySpan<TargetIndicatorId>, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ReadOnlySpan<TargetIndicatorId> span, AsyncCallback callback, object @object) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Invoke(ReadOnlySpan<TargetIndicatorId>) Declaration public virtual void Invoke(ReadOnlySpan<TargetIndicatorId> span) Parameters Type Name Description ReadOnlySpan<TargetIndicatorId> span"
  },
  "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsUpdatedDelegate.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.TargetIndicatorsUpdatedDelegate.html",
    "title": "Delegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate | Target Indicators Documentation",
    "summary": "Delegate TargetIndicatorManager.TargetIndicatorsUpdatedDelegate Delegate that passes a ReadOnlySpan of target indicators that were added or updated. Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public delegate void TargetIndicatorManager.TargetIndicatorsUpdatedDelegate(ReadOnlySpan<TargetIndicator> span) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span Delegate that passes a ReadOnlySpan of target indicators that were added or updated. Constructors TargetIndicatorsUpdatedDelegate(object, nint) Declaration public TargetIndicatorsUpdatedDelegate(object @object, nint method) Parameters Type Name Description object object nint method Methods BeginInvoke(ReadOnlySpan<TargetIndicator>, AsyncCallback, object) Declaration public virtual IAsyncResult BeginInvoke(ReadOnlySpan<TargetIndicator> span, AsyncCallback callback, object @object) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span AsyncCallback callback object object Returns Type Description IAsyncResult EndInvoke(IAsyncResult) Declaration public virtual void EndInvoke(IAsyncResult result) Parameters Type Name Description IAsyncResult result Invoke(ReadOnlySpan<TargetIndicator>) Declaration public virtual void Invoke(ReadOnlySpan<TargetIndicator> span) Parameters Type Name Description ReadOnlySpan<TargetIndicator> span"
  },
  "api/TargetIndicators.TargetIndicatorManager.html": {
    "href": "api/TargetIndicators.TargetIndicatorManager.html",
    "title": "Class TargetIndicatorManager | Target Indicators Documentation",
    "summary": "Class TargetIndicatorManager Tracks targets and transforms their world space positions into screen space coordinates with options to clamp to the screen edges, absolute size, or a compass tape. Useful for displaying directions to targets and other positions in the environment. Inheritance object TargetIndicatorManager Namespace: TargetIndicators Assembly: TargetIndicators.dll Syntax public class TargetIndicatorManager : MonoBehaviour Constructors TargetIndicatorManager() Declaration public TargetIndicatorManager() Properties BottomPadding The distance in pixels from the bottom edge of the screen for Padded boundary type. Declaration public float BottomPadding { get; set; } Property Value Type Description float BoundaryShape The shape of the boundary to clamp target indicators to. Declaration public BoundaryShape BoundaryShape { get; set; } Property Value Type Description BoundaryShape BoundaryType The type of boundary to clamp target indicators to. Declaration public BoundaryType BoundaryType { get; set; } Property Value Type Description BoundaryType Camera The scene camera that is used to calculate screen pose of tracked targets. Declaration public Camera Camera { get; set; } Property Value Type Description Camera Ellipse The definition of the currently configured ellipse if BoundaryShape is set to Ellipse. Declaration public Ellipse Ellipse { get; } Property Value Type Description Ellipse Height The height in pixels centered at the screen center for Absolute boundary type. Declaration public float Height { get; set; } Property Value Type Description float LeftPadding The distance in pixels from the left edge of the screen for Padded boundary type. Declaration public float LeftPadding { get; set; } Property Value Type Description float MaxTargets The max number of targets that can be tracked. Declaration public int MaxTargets { get; } Property Value Type Description int Rectangle The definition of the currently configured rectangle if BoundaryShape is set to Rectangle. Declaration public Rect Rectangle { get; } Property Value Type Description Rect RightPadding The distance in pixels from the right edge of the screen for Padded boundary type. Declaration public float RightPadding { get; set; } Property Value Type Description float TopPadding The distance in pixels from the top edge of the screen for Padded boundary type. Declaration public float TopPadding { get; set; } Property Value Type Description float TrackedTargetsCount The current number of targets being tracked. Declaration public int TrackedTargetsCount { get; } Property Value Type Description int Width The width in pixels centered at the screen center for Absolute boundary type. Declaration public float Width { get; set; } Property Value Type Description float Methods GetScreenPose(in Vector3, out bool) Gets the screen pose of a world space position. Declaration public Pose GetScreenPose(in Vector3 worldSpacePosition, out bool isOutsideBoundary) Parameters Type Name Description Vector3 worldSpacePosition The world space position to convert to the screen pose. bool isOutsideBoundary true if the screen pose of worldSpacePosition is outside of the configured boundary. Otherwise, false. Returns Type Description Pose The screen space pose of worldSpacePosition. IsOutsideBoundary(in Vector3) checks if the screen space position is outside the configured boundary. Declaration public bool IsOutsideBoundary(in Vector3 screenPoint) Parameters Type Name Description Vector3 screenPoint The screen point to test. Requires the point as a Vector3 to allow for the inclusion of the depth from the camera in world space for faster calculations. If unknown, set screenPoint.z to 0. Returns Type Description bool true if screenPoint is outside the configured boundary. Otherwise, false. RemoveAllTargets() Removes all targets that are being tracked. Declaration public void RemoveAllTargets() TryAddTarget(Transform, out TargetIndicator) Attempts to add a new target to be tracked. This can only fail if the TrackedTargetsCount equals MaxTargets. Declaration public bool TryAddTarget(Transform target, out TargetIndicator targetIndicator) Parameters Type Name Description Transform target The transform of the target to track. TargetIndicator targetIndicator The created TargetIndicator for the current frame of the target's position. Returns Type Description bool true if the target was added, otherwise false. TryGetTargetIndicator(TargetIndicatorId, out TargetIndicator) Attempts to get the TargetIndicator for the corresponding TargetIndicatorId. Declaration public bool TryGetTargetIndicator(TargetIndicatorId targetIndicatorId, out TargetIndicator targetIndicator) Parameters Type Name Description TargetIndicatorId targetIndicatorId The ID of the target indicator. TargetIndicator targetIndicator The TargetIndicator associated with targetIndicatorId. Returns Type Description bool true if the targetIndicatorId is valid and being tracked. Otherwise, false. TryRemoveTarget(TargetIndicatorId) Attempts to remove a target indicator. Declaration public bool TryRemoveTarget(TargetIndicatorId targetIndicatorId) Parameters Type Name Description TargetIndicatorId targetIndicatorId The ID of the target indicator to remove. Returns Type Description bool true if the targetIndicatorId is valid and being tracked. Otherwise false. Events TargetIndicatorsAdded Invoked when target indicators have been added. Declaration public event TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsAdded Event Type Type Description TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsRemoved Invoked when target indicators have been removed. Declaration public event TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorsRemoved Event Type Type Description TargetIndicatorManager.TargetIndicatorsRemovedDelegate TargetIndicatorsUpdated Invoked when target indicators have been updated. Declaration public event TargetIndicatorManager.TargetIndicatorsUpdatedDelegate TargetIndicatorsUpdated Event Type Type Description TargetIndicatorManager.TargetIndicatorsUpdatedDelegate"
  },
  "api/TargetIndicators.html": {
    "href": "api/TargetIndicators.html",
    "title": "Namespace TargetIndicators | Target Indicators Documentation",
    "summary": "Namespace TargetIndicators Classes TargetIndicatorBoundaryVisualizer Visualizes the boundary configured in a TargetIndicatorManager. Note that BoundaryType.CompassTape and BoundaryType.Unbounded has no visualization. TargetIndicatorManager Tracks targets and transforms their world space positions into screen space coordinates with options to clamp to the screen edges, absolute size, or a compass tape. Useful for displaying directions to targets and other positions in the environment. Structs Ellipse The data that defines the ellipse of the screen boundary. TargetIndicator The contextual data that defines a tracked target in screen space. TargetIndicatorId The unique ID that represents a TargetIndicator. Enums BoundaryShape The shape of the boundary for Padded or Absolute boundary types that target indicators will clamp to. BoundaryType The type of boundary that target indicators will clamp to. Delegates TargetIndicatorManager.TargetIndicatorsRemovedDelegate Delegate that passes a ReadOnlySpan of target indicators that were removed. TargetIndicatorManager.TargetIndicatorsUpdatedDelegate Delegate that passes a ReadOnlySpan of target indicators that were added or updated."
  },
  "get-target-indicators.html": {
    "href": "get-target-indicators.html",
    "title": "",
    "summary": ""
  },
  "index.html": {
    "href": "index.html",
    "title": "",
    "summary": ""
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Target Indicators | Target Indicators Documentation",
    "summary": "Target Indicators Target Indicators is a Unity package that enables you to create visual indicators to track world-space targets. Guide users to points of interest, waypoints, or other in-game places. Customize indicators to fit your project's style and requirements. The package integrates with any UI system, offering an API to calculate and bound screen-space positions for any target. It includes ready-to-use Sample Assets for a quick, low-code setup, also serving as an excellent references for building fully custom visual indicators. Note Get Target Indicators on the Unity Asset Store. function resizeYoutubeIframe() { var container = document.getElementById('responsive-youtube-container'); var iframe = document.getElementById('responsive-youtube-iframe'); if (container && iframe) { var width = container.offsetWidth; // Get current width of the container var aspectRatio = 9 / 16; // For 16:9 aspect ratio (height / width) var newHeight = width * aspectRatio; iframe.style.height = newHeight + 'px'; } } // Initial resize resizeYoutubeIframe(); // Add event listener for window resize window.addEventListener('resize', resizeYoutubeIframe); Highlights Target indicators focuses on simplicity and high performance. The following highlights are what you can expect from this package: Supports rectangle and ellipse screen bounds clamping Supports rectangle and ellipse absolute size clamping Supports compass tape clamping Supports unbounded clamping Works with any UI system* Highly configurable at edit and runtime No heap allocations after initialization Does not rely on Object.Find or any variations of scene searching at runtime Does not rely on GetComponent Supports fast enter play mode (no domain reload when entering Play Mode) Simple and minimal sample scenes Works with traditional displays and XR HMDs Note *The package has a dependency on com.unity.ugui to support the sample scenes but you are not required to use uGUI to work with target indicators. Dependencies The following dependencies are required for target indicators. Unity version Unity 6000.0 or newer Packages com.unity.inputsystem 1.14.0 for samples com.unity.ugui 2.0.0 for samples"
  },
  "manual/install-package.html": {
    "href": "manual/install-package.html",
    "title": "Install package | Target Indicators Documentation",
    "summary": "Install package Once purchased, follow these steps to add the Target Indicators package to your project: Open the package manager via Window > Package Management > Package Manager. In the package manager window navigate to My Assets and search for Target Indicators and click Download. After the packages has downloaded you should find the package contents in the Project Window > Packages > Target Indicators. Refer to the samples documentation to learn more about the provided samples."
  },
  "manual/samples/sample-scenes.html": {
    "href": "manual/samples/sample-scenes.html",
    "title": "Sample scenes | Target Indicators Documentation",
    "summary": "Sample scenes The sample scenes are located in Assets/Target Indicators/Samples/Scenes. The structure of each scene includes a group of helper scene objects that are unrelated to target indicators but required for the sample scene to work, such as the environment objects, directional light, event system, etc. The target indicators related scripts are located under the --- Target Indicator Managers --- GameObject in the hiearchy. This is where you can find how target indicators are setup in the scene and the targets that are being tracked. The visual indicators that get instantiated for the UI uses uGUI (Unity UI) and are parented under the Canvas beneath the --- UI --- GameObject in the hiearchy. Important If you import the sample's starter assets and do not see text displayed in the scenes, you need to import the text mesh pro essentials. Navigate to Window > TextMeshPro > Import TMP Essential Resources and import. Scene interactions Each scene has a simple first person controller script attached the to scenes Camera GameObject. To enable input while in play mode, press the Escape key on the keyboard to enable focus. A visual indicator of the current focus state can be found in the top right of the Game window and looks like a gray square. The indicator will be white when focused and gray when unfocused. While focused, click the mouse anywhere in the Game window to hide the cursor. Pressing Escape will unfocus the game and reveal the cursor. Focus and unfocus the game to edit the target indicator manager settings and experiement without having to exit play mode. When the game is focused you can move around with WASD and look around with the mouse. Scenes There are three scenes to demonstrate a few variations of using target indicators. The following sections describes each scene in more detail. Simple Target Indicators Demo This scene demonstrates a minimal version of target indicators and is a good starting point. It uses only one visual indicator manager and one visual indicator prefab. The assigned default visual indicator prefab assigned in the visual indicator manager is what indicators get instantiated in the scene. They are parented to the Canvas under the Target Indicators Content GameObject. The Simple Targets Indicators Setup Example GameObject contains a script SimpleTargetIndicatorSetupExample that shows a minimal code example for assigning targets to the target indicator manager on Start. Note Changing the target indicator manager's boundary type to compass tape will stop the target indicators from updating. Compass tape boundary types require special configuration. Refer to compass tape visual indicator manager to learn how to work with a compass tape target indicator. Compass Tape Target Indicators Demo This scene demonstrates how to setup a compass tape target indicator. The target indicator manager's BoundaryType is set to CompassTape and uses the CompassTapeVisualIndicator on the Compass Tape Visual Indicator Manager GameObject. The default visual indicator prefab uses the CompassTapeVisualIndicator prefab. The compass tape visual indicators are instantiated and parented to the UI Compass Tape Indicators Content GameObject under the Canvas. The Compass Tape Target Indicators Setup Example GameObject contains a script CompassTapeTargetIndicatorsSetupExample that shows a minimal code example for assigning targets to the compass target visual indicator manager on Start. Multiple Target Indicator Categories Demo This scene demonstrates using multiple target indicator managers for different visual indicator categories. There are two target indicator managers that both use padded boundary type but with different padding values. The reason is because one of the visual indicators, the Enemy Target Indicator found in the Example Assets prefabs folder, has an offset raised by 10 pixels. Therefore it uses a target indicator manager with an adjusted boundary so it aligns with the other visual indicators on the screen. The Multiple Target Categories Setup Example GameObject contains a script MultipleTargetIndicatorCategoriesExample that shows a minimal code example for assigning targets with different visual indicators to two different visual indicator managers on Start."
  },
  "manual/samples/samples-overview.html": {
    "href": "manual/samples/samples-overview.html",
    "title": "Samples Overview | Target Indicators Documentation",
    "summary": "Samples Overview The Sample Assets provide a collection of scenes and assets that demonstrate the features of Target Indicators. They also include preconfigured scripts and prefabs for visual indicators. Use these assets directly for immediate implementation, or as templates for your custom variants. Important If you import the sample's starter assets and do not see text displayed in the scenes, you need to import the text mesh pro essentials. Navigate to Window > TextMeshPro > Import TMP Essential Resources and import. Sample assets The assets are grouped into two parts: Core Assets Core assets that are located in Assets/Target Indicators/Samples/Core Assets and contains the set of scripts, prefabs, and textures for you to use directly or as a foundation for your own visual indicators. Example Assets Example assets that are located in Assets/Target Indicators/Samples/Example Assets and contains the scripts, prefabs, and other assets needed for the sample scenes to work such as a camera controller. Visual indicators The sample scenes rely on two main components for visualizing target indicators: Visual indicator manager This component interacts with the target indicator manager and handles instantiating visual indicator prefabs and updating their state. To learn more about how to setup and use the sample's visual indicator manager, refer to visual indicator manager component. Visual indicator This component gets attached to prefabs and is what the visual indicator manager instantiates for new visual indicators. To learn more about how to setup and use the sample's visual indicator, refer to visual indicator component."
  },
  "manual/samples/samples.html": {
    "href": "manual/samples/samples.html",
    "title": "Samples | Target Indicators Documentation",
    "summary": "Samples Refer to the following topics to understand the samples and how to use them: Topic Description Samples Overview Understand how the samples work. Visual indicator manager component Understand how to setup and use the visual indicator manager component. Visual indicator component Understand how to setup and use the visual indicator component with prefabs. Sample scenes Understand the different sample scenes."
  },
  "manual/samples/visual-indicator-component.html": {
    "href": "manual/samples/visual-indicator-component.html",
    "title": "Visual indicator component | Target Indicators Documentation",
    "summary": "Visual indicator component The visual indicator component is instantiated by the VisualIndicatorManager and controls each instance of a visual indicator prefab. SerializedFields and properties The following sections describes each references and settings of the component: Core Indicator content This is the root content that will be visible in the UI. Any imagery or text that is part of the core visual indicator should be parented to this transform. Rotation content This is the root content for image or text that will be rotated to point at the target the visual indicator is tracking. Any arrows or other imagery should be parented to this transform. Core Indicator visibility This determines how the indicator content will be visibile for a given state. This property does not affect the rotation content visibility. Refer to Indicator visibility to learn more about the options. Rotation content visibility This determines how the indicator's rotation content will be visible for a given state. This property does not affect the indicator visibility. Refer to Indicator visibility to learn more about the options. Indicator visibility There are four types of indicator visibility that determines how visual indicator's content and their rotation content will be visible for any given state: Never The content is never visible. This is typically only useful for rotation content where you don't want to show an arrow or any additional content that rotates to point at a target. Always The content is always visible. Outside boundary The content is only visible when the target is outside the boundary. This is typically used for the rotation content when you want an arrow to point at the target when it is outside the boundary. Inside boundary The content is only visible when the taret is inside the boundary. This is typically used for compass tape visual indicators where you only want the indicator visible when inside the bounds of the compass tape. Set up a prefab The visual indicator prefabs provided in in Assets/Target Indicators/Samples/Core Assets/Prefabs is a good reference for building your own indicators. Create a prefab variant to use it as a template or make a new one from scratch. Visual indicator The following image labels the key components of a visual indicator. The core visual indicator content that is parented to the Core Content in the hiearchy. The visual indicator rotation content that is parented to the Rotation Content in the hiearchy. The VisualIndicator component and it's assigned references and settings. Compass tape visual indicator The CompassTapeVisualIndicator inherits from the base VisualIndicator. Like the base visual indicator, the compass tape visual indicator has the same configuration. The reason for a special CompassTapeVisualIndicator component is to handle the unique interpreting of screen pose values for compass tape target indicators. The core visual indicator content that is parented to the Core Content in the hiearchy. The CompassTapeVisualIndicator component and its assigned references and settings. Typically the RotationContentVisibility is unused for compass tapes and set to Never. Compass tape boundary check Due to the special nature of compass tape target indicators, you are responsible for checking if the indicator is outside of the compass tape boundary. The provided samples handles this in CompassTapeVisualIndicator.UpdateVisualIndicator(Pose, bool). Note Refer to Compass tape boundary type to remind yourself how compass tapes work. To calculate if the target indicator screen position is outside the boundary of the visible tape, use the following steps: Calculate the full tape to visible tape ratio Calculate the ratio between the length of the full tape and the length of the visible tape by dividing the length of the UI element for the full tape by the length of the UI element for the visible tape. For example, if the full tape length is 1000 pixels long and the visible tape is 500 pixels long, the ratio would be 1000 รท 500 = 2 meaning the full tape length is twice the length of the visible tape. Calculate the target position on the full tape Remember that the target indicator manager returns a normalized value between 0 and 1 representing the target's cardinal direction relative to the user's forward direction. Take the screenPose.position.x received from the target indicator manager and multiply it with the full tape to visible tape ratio from the previous step. Finally multiply the product by the length of the visible tape. For example, if the target indicator manager returns 0.25 for the X position of the target and the visible tape length is 500 pixels long as described in the previous step, the position on the full tape would be 0.25 * 2 * 500 = 250. Calculate the distance from the position on the full tape to the middle of the full tape Take the result from step 2 and subtract half of the full tape length. 250 - (1000 * 0.5) = -250 Calculate the position on the visible tape Add half of the visible tape to the result from step 3. (500 * 0.5) + (-250) = 0 Check if the position is outside the boundary If the result from step 5 is less than 0 or greater than the length of the visible tape then we know it is outside of the boundary. In our example the result is 0 indicating it's at the very begininning position on the visible tape. Refer to the following code example to understand how these steps are implemented: float _fullTapeToVisibleTapeRatio = 2f; float _visibleTapeLength = 500f; public bool IsScreenPointOutsideBoundary(Pose screenPose) { screenPose.position.x %= 1f; var positionOnFullTape = screenPose.position.x * (_fullTapeToVisibleTapeRatio * _visibleTapeLength); var middleOfFullTape = (_fullTapeToVisibleTapeRatio * _visibleTapeLength) * 0.5f; var middleToPositionOnFullTape = positionOnFullTape - middleOfFullTape; var middleOfVisibleTape = _visibleTapeLength * 0.5f; var pointOnVisibleTape = middleOfVisibleTape + middleToPositionOnFullTape; return pointOnVisibleTape < 0 || pointOnVisibleTape > _visibleTapeLength; }"
  },
  "manual/samples/visual-indicator-manager-component.html": {
    "href": "manual/samples/visual-indicator-manager-component.html",
    "title": "Visual indicator manager component | Target Indicators Documentation",
    "summary": "Visual indicator manager component The visual indicator manager component works with the TargetIndicatorManager and instantiates visual indicator prefabs and updates their state. There are several properties to configure for the component to work. References and settings The following sections describes each reference and settings of the component: Default visual indicator prefab This is a reference to the visual indicator prefab that will be instantiated in the UI by default when a target is added. You can assign this in the inspector or change it at runtime by assigning the DefaultVisualIndicatorPrefab. Target indicator manager This is a reference to the TargetIndicatorManager component in the scene that you want this visual indicator manager to interact with and respond to. Canvas This is the Canvas the visual indicators will be a part of. This reference is used in the calculation for the position to place visual indicators when the canvas scale changes. The canvas scale can change when using ScreenMatchMode.MatchWidthOrHeight on the CanvasScaler. Content This is the RectTransform in the Canvas you want to instantiate your visual indicators and parent them to. Add indicator mode This property controls whether visual indicators should automatically be created when the TargetIndicatorManager adds targets. If set to manual, it will only instantiate visual indicators when you call TargetIndicatorManager.AddTargetIndicator. API The visual indicator manager offers several APIs for you to have more control over what visual indicators get instantiated and when. Add target indicator If you want the visual indicator manager to track every target that is added to the target indicator manager you can add targets directly to the TargetIndicatorManager and leave the AddIndicatorMode to Auto. This way the visual indicator manager will automatically instantiate and update visual indicators. If you want the visual indicator manager to track specific targets from the target indicator manager, set the AddIndicatorMode to Manual and use one of the following APIs: AddTargetIndicator(Transform target) This API takes a transform of a target to track and adds it to the target indicator manager. It instantiates the default visual indicator prefab. AddTargetIndicator(Transform target, VisualIndicator indicatorPrefab) This API takes a transform of a target to track and adds it to the target indicator manager. It instantiates a new instance from the indicatorPrefab passed in as the second argument. Use this when you want a specific visual indicator for a target. Hide a visual Indicator VisualIndicator.HideVisualIndicator will hide the content and rotation content of a visual indicator without disabling the component at the root. Use this to temporarily hide a visual indicator if you don't want to destroy it. Show a visual Indicator VisualIndicator.ShowVisualIndicator This API shows the content and rotation content of a visual indicator that was previously hidden. Use this to show hidden indicators from HideVisualIndicator. Visual indicators are shown when first instantiated. RemoveTargetIndicator VisualIndicator.RemoveTargetIndicator removes a target from the target indicator manager. Use this when you are done tracking a target and want to destroy the visual indicator. Compass tape visual indicator manager The CompassTapeVisualIndicatorManager inhertis from VisualIndicatorManager and is specialized for handling target indicator managers with a CompassTape boundary type. It follows the same setup pattern. Use this class as an example to inherit the base visual indicator manager overriding the functionality with custom behavior. It requires a special implementation of CompassTapeVisualIndicator prefab for its DefaultVisualIndicatorPrefab. Refer to compass tape visual indicator for more information. Full tape to visible tape ratio This is a unique property on the CompassTapeVisualIndicatorManager that is used for calculating the position on the compass tape's RectTransform to place the visual indicator. The value represents the ratio between the full tape and the visible tape. For example, if the full tape is twice the length of the visible tape this value would be 2. Refer to compass tape boundary type to learn more about how compass tapes work."
  },
  "manual/support-and-feedback.html": {
    "href": "manual/support-and-feedback.html",
    "title": "Support and Feedback | Target Indicators Documentation",
    "summary": "Support and Feedback If you need assistance, have questions, want to provide feedback, request new features, or report a bug, please email me at: targetindicators.help@outlook.com To help me assist you efficiently, please include the following information in your email: Subject Line: Clearly state the purpose of your email with one of the following: \"Feedback\" \"Question\" \"Feature Request\" \"Bug Report\" For Bug Reports: Steps to teproduce: Provide minimal, clear steps to consistently reproduce the issue. Supporting media: Include relevant pictures or videos if they help illustrate the problem. Versions: Specify the Unity version and the Target Indicators package version you are using."
  },
  "manual/user-guide.html": {
    "href": "manual/user-guide.html",
    "title": "User Guide | Target Indicators Documentation",
    "summary": "User Guide Refer to the following topics to understand target indicators and how to use them: Topic Description Overview Understand how target indicators work. Target Indicator Manager Understand how to configure and use the Target Indicator Manager component. Target Indicator Understand how to use target indicators created by the target indicator manager. uGUI indicators Understand how to configure target indicators for Unity UI. XR indicators Understand how to configure target indicators for XR."
  },
  "manual/user_guide/overview.html": {
    "href": "manual/user_guide/overview.html",
    "title": "Overview | Target Indicators Documentation",
    "summary": "Overview Target Indicators provides pixel-based screen coordinates for 3D world-space positions. These coordinates represent the screen-space projection of a target, even when it's off screen. If configured, the system clamps these screen coordinates to the edges of the display, indicating the direction to the target. This is useful in games or applications when guiding users to objectives or other points of interest that are not currently in the camera's view. Beyond basic positioning, Target Indicators also offers contextual data about a target. Including, for example, the rotation required to point an arrow directly at the target in screen space, or whether the target lies outside a predefined screen boundary. Main components The target indicator system is comprised of two main components. Target Indicator Manager The Target Indicator Manager handles all tracked targets. It calculates the necessary data for positioning visual indicators on the screen. You can use it to manage the lifecycle events of indicators, receiving notifications when they change, or retrieve screen-space data directly for custom lifecycle control. This manager integrates with any UI system, as it solely focuses on converting world-space positions to screen-space coordinates. Its configurable options allow you to define the boundary type, shape, and size, customizing the screen boundary for your application's requirements. Tip The Target Indicators package offers Samples that provides prefabs using uGUI that you can customize for your project's needs if you don't want to build your own visual indicators. Target Indicator A Target Indicator is the data structure generated by the target indicator manager that holds screen-space information for visualizing a tracked target. While it functions as a conceptual component within the system's design, a TargetIndicator is a C# struct, not a Unity Component that attaches to GameObjects. This struct contains relevant information about a tracked target, such as the screen pose (coordinates and rotation), the target it's tracking, and if it's outside the configured boundary."
  },
  "manual/user_guide/target-indicator-manager.html": {
    "href": "manual/user_guide/target-indicator-manager.html",
    "title": "Target Indicator Manager | Target Indicators Documentation",
    "summary": "Target Indicator Manager The TargetIndicatorManager component is central to Target Indicators. It manages the lifecycle of all tracked targets, handling their addition, updates, and removal. This manager generates the screen-space data needed to position visual indicators. The following sections explain how to use the target indicator manager. Important By default Target Indicators does not display any UI on the scene. It only returns screen coordinates for you to display your own indicators. If you are interested in prebuilt visual indicators you can import the sample's starter assets which provides a solution with Unity UI. Refer to the Samples to learn more about how to configure the prebuilt indicators. Scene Setup Add the TargetIndicatorManager to a GameObject in the hiearchy and edit the configuration to your projects needs. Configure the Target Indicator Manager The TargetIndicatorManager has several properties that can be edited within the inspector or set at runtime. The following sections explains each property in more detail. Camera The camera is used for calculating the screen space coordinates of each target. By default, when the TargetIndicatorManager component is added or reset it will assign the camera in your scene with the MainCamera tag. If no camera has the MainCamera tag it will fallback to using the first camera in the scene. Assign the camera that you will be using to display target indicators. To assign the camera reference at runtime, use TargetIndicatorManager.Camera. Boundary type The BoundaryType property controls how visual indicators are bounded. For example indicators can be bounded by the screen edges or have no boundary at all. There are four boundary types: Padded This boundary type clamps target indicators to the screen edges while applying an adjustable padding defined in pixels. Indicators automatically adapt to changes in screen size, maintaining their padding and visibility. Padded boundary is common for indicating waypoints, enemies, and points of interest. Absolute This boundary type clamps target indicators to the screen with a fixed size defined in pixels. It will not change if the screen size changes. Absolute boundary is common in first person games where you want to indicate the direction a player or other character is attacking from when not directly in front of the user. Compass Tape This boundary type maps the direction of targets to a horizontal range, simulating a compass tape. Unlike other boundary types, it does not provide pixel-based screen coordinates. Instead, it offers a normalized value between 0 and 1 representing the target's cardinal direction relative to the user's forward direction. To learn more about how to use the screen pose for compass tape indicators, refer to Interpret the screen pose. Unbounded This boundary type places visual indicators directly at the target's screen pose without any clamping. Consequently, if the target moves off-screen, its corresponding visual indicator will also move off-screen. Boundary shape When using Padded or Absolute boundary types, configure the shape of the boundary with the BoundaryShape property. There are two boundary shapes: Rectangle TargetIndicatorManager.Rectangle represents the rectangle data generated by the currnet configuration. Ellipse TargetIndicatorManager.Ellipse represents the ellipse data generated by the current configuration. Padding When BoundaryType is set to Padded, you can define the pixel distance between the screen edges and the visual indicator's boundary. Padding can be independently configured for the Top, Bottom, Left, and Right edges. These properties are ignored if BoundaryType is not Padded. Width and Height When BoundaryType is set to Absolute, the boundary's dimensions are defined by the Width and Height properties. Unlike other boundary types, this size remains fixed and does not adapt to changes in screen size. These properties are ignored if BoundaryType is not Absolute. Visualize the boundary You can visualize your current configuration at edit time and at runtime with the TargetIndicatorBoundaryVisualizer component. The following sections describe how to use the TargetIndicatorBoundaryVisualizer to visualize the configured boundary. Add visualizer Attach the TargetIndicatorBoundaryVisualizer component by clicking the Add Boundary Visualizer button on the bottom of the target indicator manager component. Once added, you can remove the visualizer by clicking the Remove Boundary Visualizer button. Note Only BoundaryType.Padded and BoundaryType.Absolute can be visualized with the built in visualizer. Edit visualizer Boundary line color and line width properties are available in the inspector to modify the boundary visualizer. This is useful if you have multiple target indicator managers and need to distinguish easily between them. Create a custom visualizer The provided TargetIndicatorBoundaryVisualizer uses a LineRenderer and draws the boundary in front of the camera, updating it's position as the camera moves. This is to reduce the dependency on better screen space solutions such as Unity UI, UI Toolkit, or a custom shader. Because it uses a LineRenderer it can have strange side effects if your camera moves quickly or has an extreme field of view. If your project has a special camera configuration where the provided boundary visualizer does not adequately meet your needs, you can create your own boundary visualizer. Use the data provided by TargetIndicatorManager.Rectangle or TargetIndicatorManager.Ellipse to draw your own visualizer. API The following sections describe how to use the target indicator manager API. Add a target Add targets to track and receive updates for target indicators The max number of targets that can be tracked at once is 100. TryAddTarget can only fail if you try to add more than 100 targets. To get the current number of tracked targets use TrackedTargetsCount. If you need more than 100 (god bless), you can use multiple target indicator managers. To add a target to track use TryAddTarget as shown in the following code example: public void TryAddTargetExample(TargetIndicatorManager manager, Transform target) { var wasAdded = manager.TryAddTarget(target, out var targetIndicator); if (!wasAdded) { // Failed to add target because max limit of targets is reached. // Handle error. return; } // Successfully added target. } Keep track of the returned TargetIndicator.TrackedIndicatorId in the out parameter to know which target indicator corresponds to a target. Remove a target Remove targets to have the target indicator manager stop tracking and sending updates for a target. Removing a target can only fail if you pass an invalid TargetIndicatorId. To remove a target from being tracked use TryRemoveTarget as shown in the following code example: public void TryRemoveTargetExample(TargetIndicatorManager manager, TargetIndicatorId id) { var wasRemoved = manager.TryRemoveTarget(id); if (!wasRemoved) { // Failed to remove target because the target indicator ID was invalid. // Handle error. return; } // Successfully removed target. } Remove all targets To remove all targets at once use RemoveAllTargets as shown in the following code example: public void RemoveAllTargetsExample(TargetIndicatorManager manager) { manager.RemoveAllTargets(); // Successfully removed all tracked targets. } Tip If you just want to stop receiving updates you can disable the TargetIndicatorManager component. Re-enabling it will resume tracking targets. Get a target To check if a target indicator is being tracked use TryGetTargetIndicator as shown in the following code example: public void GetATargetIndicatorExample( TargetIndicatorManager manager, TargetIndicatorId id) { var didGet = manager.TryGetTargetIndicator(id, out var targetIndicator); if (!didGet) { // Failed to get target because target indicator ID was invalid. // Handle error. return; } // Successfully received target indicator. } Get screen pose If you want to get the screen pose of any world space position that adherers to your current boundary, use GetScreenPose. This can be useful if you want to control your own life cycle, or if you only need a one time update, or you need infrequent updates for a target's screen pose. The following code example shows you how to use GetScreenPose: public void GetScreenPoseExample( TargetIndicatorManager manager, Vector3 worldSpacePosition) { var screenPose = manager.GetScreenPose(worldSpacePosition, out var isOutsideBoundary); // screenPose.position.x = horizontal axis coordinate in screen space (pixels). // screenPose.position.y = vertical axis coordinate in screen space (pixels). // screenPose.position.z = depth from the camera in world space (meters). // screenPose.rotation = direction to target in screen space. // isOutsideBoundary = true if the screenPose.position is outside the configured // boundary. The depth from the camera is ignored in this check. } Is outside boundary Each TargetIndicator contains an IsOutsideBoundary property that you can use to know if a target indicator is outside the configured boundary. If you want to know if any world space position is outside the current boundary use TargetIndicatorManager.TargetIndicators.TargetIndicatorManager.IsOutsideBoundary as shown in the following example: public void IsOutsideBoundaryExample( TargetIndicatorManager manager, Vector3 worldSpacePosition) { var isOutsideBoundary = manager.IsOutsideBoundary(worldSpacePosition); // isOutsideBoundary = true if the screen pose coordinates are outside the // configured boundary. The depth from the camera is ignored in this check. } Important For BoundaryType.CompassTape and BoundaryType.Unbounded the IsOutsideBoundary property will always be false. BoundaryType.Compass requires knowledge about your specific compass tape setup to determine if it's outside the boundary. Refer to Compass tape boundary check to learn how you can check if the target indicator is outside of your compass tape boundary. Life cycle events While enabled, the TargetIndicatorManager component will check for changes every frame. If any anchors were added, updated, or removed, TargetIndicatorManager will invoke TargetIndicatorsAdded, TargetIndicatorsUpdated, and TargetIndicatorsRemoved events respectively. Each event passes a ReadOnlySpan that wraps an underlying array. This avoids heap allocations and slices the array to the size of changes that occurred since the last time the events were invoked. The following code example shows how you can subscribe to these events and iterate over the spans of target indicators they pass: public void LifeCycleExample(TargetIndicatorManager manager) { manager.TargetIndicatorsAdded += OnTargetIndicatorsAdded; manager.TargetIndicatorsUpdated += OnTargetIndicatorsUpdated; manager.TargetIndicatorsRemoved += OnTargetIndicatorsRemoved; } void OnTargetIndicatorsAdded(ReadOnlySpan<TargetIndicator> added) { foreach (var targetIndicator in added) { var screenPose = targetIndicator.ScreenPose; } } void OnTargetIndicatorsUpdated(ReadOnlySpan<TargetIndicator> updated) { foreach (var targetIndicator in updated) { var updatedScreenPose = targetIndicator.ScreenPose; } } void OnTargetIndicatorsRemoved(ReadOnlySpan<TargetIndicatorId> removed) { foreach (var targetIndicatorId in removed) { // TargetIndicatorId was removed. } } You can disable the TargetIndicatorManager component to stop receiving life cycle events and control your own life cycle and rely on the TargetIndicatorManager exclusively for pose and boundary checks. Using multiple target indicator managers Some applications might require multiple boundary types or multiple configurations. You can have multiple TargetIndicatorManager components in your scene to get more complex designs. For example if you use BoundaryType.CompassTape you will only get indicators to display on the compass tape but might not know what target they correspond to. You can have a second TargetIndicatorManager that is configured to use BoundaryType.Unbounded that marks the same target with a matching icon as used in your compass tape visualizer to indicate which target represents which marker in your compass tape indicator. The Samples provides an example of how to configre multiple target indicator managers."
  },
  "manual/user_guide/target-indicator.html": {
    "href": "manual/user_guide/target-indicator.html",
    "title": "Target Indicator | Target Indicators Documentation",
    "summary": "Target Indicator A Target Indicator is a C# struct that contains the properties necessary for placing indicators on the screen to track a target. The following sections explains the target indicator properties and how they map to the screen in more detail. Target indicator id The TargetIndicatorId property is the unique ID associated with a target indicator. It is generated by the Target indicator manager for each target and persists until the target is removed. If a target is added back to the target indicator manager after it has been removed, it will have a new target indicator ID. Target The target is the transform that the target indicator is tracking. The position of the target is what gets transformed to the screen coordinates for the target indicator. Screen pose The ScreenPose property is a Pose that contains the position and rotation of the target indicator for placement of a visual indicator. The values stored in the position and rotation of the pose differ between the boundary type when the target indicator was created. Refer to interpret the screen pose to learn how to use the respective pose values. Is outside boundary The IsOutsideBoundary property indicates if the screen pose of the target is outside of the boundary configured by the target indicator manager when the target indicator was created. The IsOutsideBoundary property will not update on existing target indicators structs if the boundary changes. You should wait for an updated target indicator via the life cycle events to get the updated state or use TargetIndicatorManager.IsOutsideBoundary. Important For BoundaryType.CompassTape and BoundaryType.Unbounded the IsOutsideBoundary property will always be false. BoundaryType.Compass requires knowledge about your specific compass tape setup to determine if it's outside the boundary.sTape Refer to Compass tape boundary check to learn how you can check if the target indicator is outside of your compass tape boundary. Screen coordinates Target indicators uses screen coordinates in pixels to describe the placement of a target indicator. The bottom left of the screen corresponds to coordinate (0, 0) and the top right of the screen corresponds to (Screen.width, Screen.height). Interpret the screen pose Depending on your target indicator manager's boundary configuration, the screen pose values can be interpreted differently. The following sections describe how to interpret the ScreenPose for different boundary types. Warning If you are using uGUI (Unity UI), the coordinates can be affected by the Canvas.renderMode. Refer to uGUI indicators to learn more about how to handle different render modes. Padded boundary type The ScreenPose.position.x and ScreenPose.position.y components correspond directly to screen coordinates. This means you should place your visual indicator at those exact coordiantes. The ScreenPose.position.z component corresponds to the depth from the camera the target is in world space. This can be helpful to know if a target is behind you. It is not needed for placing visual indicators on the screen. The ScreenPose.rotation property indicates the direction to rotate towards the target in screen space from the right vector (1, 0). This is useful if you want to have an arrow pointing at the target in screen space when the target is outside the boundary. Refer to the image below to understand how rotations apply to target indicators. This image shows the screen space coordinate system and the rotation of a target indicator. The indicator has a rotation of 130ยฐ relative to the right vector (1, 0) in screen space. Use this value to rotate an arrow to point at the target. The vector in screen space that the rotation of a screen pose is relative to. The vector pointing to the target indicators screen pose. This is the vector used to calculate the angle. Absolute boundary type Like the padded boundary type, the absolute boundary uses the ScreenPose.position and ScreenPose.rotation the same. Compass tape boundary type Unlike the Padded and Absolute boundary types, the CompassTape boundary type does not provide direct pixel screen coordinates. Instead, TargetIndicator.ScreenPose.x contains a normalized value between 0 and 1, representing the target's horizontal position on the tape. A value of 0.5 represents directly in front of the user while a value of 0.25 represents to the left, 0.75 represents to the right, and both 0 and 1 represent directly behind the user. All other ScreenPose components will be 0. The screen pose rotation will be Quaternion.identity. Compass tape primer Compass tapes are compasses that are displayed as a horizontal strip with a scrolling texture as the user turns around the Y, or up, axis and the middle of the compass always corresponds to the direction the user is facing. Compass tapes are broken up into two parts: Full tape Full tape is the part of the compass tape that reprsents the full spectrum of cardinal directions north, east, south, and west. It is the length of the UI element, or distance to scroll the compass texture for one full rotation. The full tape is not always visible as it requires a texture to scroll and wrap around the tape as the user makes a full rotation. Visible tape Visible tape refers to the part of the compass tape that is visible at any given time and is shorter than the full tape length. Often the visible tape is half the length of the full tape. Refer to the image below to understand how the screen pose for a compass tape is mapped to a compass tape. This image represents looking down onto a player on the XZ plane of the world. The point where the user is standing facing the positive Z axis. The point directly behind the player that corresponds to 0, or the left end of the full tape. The values increase around the circle in a clockwise rotation. The point directly in front of the player that corresponds to 0.5, or half way across the full tape. The point also directly behind the player that corresponds to 1, or the right end of the full tape. This is the highest value on the compass tape and rotating clockwise beyond this point will wrap the value back to 0. The point of a tracked target in front of and to the left of the player. The value will be โ 0.3, or about one third from the left end of the full tape represented by the matching green circles. The left end of the full tape. The left end of the visible tape. The right end of the visible tape. The right end of the full tape. A target that is directly in front of the player will have a ScreenPose.position.x value of 0.5. As the target moves around the player in a clockwise rotation, its value will increase to 1 as it reaches directly behind the player. If the target continues to move in a clockwise rotation from behind the player, its value will wrap to 0 and increase back to 0.5 as it reached to its starting point directly in front of the player. You can use this 0 to 1 value to know where on your full tape the indicator should be placed. Unbounded boundary type Similar to Padded and Absolute boundary types, Unbounded uses direct pixel screen coordinates. However, when a target moves outside the camera's field of view, its corresponding visual indicator will also move off-screen, as it is not clamped to the screen edges. When a target rotates behind the player, resulting in TargetIndicator.ScreenPose.position.z becoming less than 0, the system sets TargetIndicator.ScreenPose.position.x to float.MaxValue. This ensures visual indicators do not incorrectly appear on screen when their target is behind the player."
  },
  "manual/user_guide/ugui-indicators.html": {
    "href": "manual/user_guide/ugui-indicators.html",
    "title": "uGUI indicators | Target Indicators Documentation",
    "summary": "uGUI indicators A TargetIndicator is a C# struct containing screen-space data, not a visual element. To display this data, you must create your own visual indicator. Building visual indicators with Unity UI requires understanding the RectTransform system, specifically the relationship between a visual indicator's RectTransform and its parent's RectTransform. Visual Indicator Parent RectTransform The RectTransform of a visual indicator's parent significantly influences how indicators are positioned on the screen, particularly due to its anchors, size, and pivot. To ensure a target's ScreenPose.position directly corresponds to the anchoredPosition of a child visual indicator, the parent RectTransform should have its anchorMin set to (0, 0) and its anchorMax set to (1, 1). This configuration ensures the visual indicators reposition correctly regardless of the parent's pivot or size, and adapts to screen size changes. Visual Indicator RectTransform To position a visual indicator's RectTransform at a target's screen pose, assign the TargetIndicator.ScreenPose.position value to RectTransform.anchoredPosition. For the visual indicator to be perfectly centered on the target's screen pose, set its anchorMin, anchorMax, and pivot properties to (0.5, 0.5). If you need to offset a visual indicator from the target's precise screen pose, for example to place an arrow tip at the coordinate, create a child GameObject for the offset and parent the visual content to it. By applying the TargetIndicator.ScreenPose.position directly to the main visual indicator RectTransform, the desired offset will be maintained through the GameObject hierarchy. Canvas render mode For consistent and reliable results, use the Screen Space - Overlay Canvas Render Mode. This ensures visual indicators are always drawn on top of the 3D environment, preventing occlusion. If you use Screen Space - Camera and assign a camera, visual indicators can be occluded by scene geometry. This occurs if the Canvas's plane distance places it behind objects in the camera's view. Important Changing the CanvasScaler.uiScaleMode can alter the Canvas's scale, which affects how screen coordinates are interpreted. When applying TargetIndicator screen poses to your visual indicators, ensure you account for the Canvas's current scale. For instance, if the Canvas's scale factor is 0.5, you must double the TargetIndicator screen pose values to achieve correct placement."
  },
  "manual/user_guide/xr-indicators.html": {
    "href": "manual/user_guide/xr-indicators.html",
    "title": "XR indicators | Target Indicators Documentation",
    "summary": "XR indicators A common challenge in XR applications is effectively guiding users to important off-screen items or locations within their virtual environment. Target Indicators can provide this guidance by directing users towards targets in their environment. This specific approach for XR has particular configuration requirements. Configure target indicators for XR The following steps outline how to set up your scene: Set your BoundaryType to Absolute. Adjust the Width and Height properties to define your boundary size. Display your visual indicators on a Canvas configured to Screen Space - Camera render mode. Tip When using Screen Space - Camera, visual indicators can be occluded by scene geometry. To minimize this, adjust the Canvas's Plane Distance to be closer to the camera, or consider using an overlay shader that forces the UI to draw on top of all scene geometry. Current limitations While usable, the current screen-space solution for XR has some limitations: Screen Space UI - The package currently relies on screen-space UI. While Screen Space - Camera is used, true world-space UI, which is generally recommended for XR applications to provide a more immersive and stable experience, is not directly supported. Jitter and Shaking: Due to the nature of converting world-space targets to screen space, visual indicators may appear shaky or jittery on the display, particularly during small head movements or vibrations of the XR headset. This can detract from user comfort and visual stability. I'm open to developing a more robust, XR-centric solution if there is sufficient demand from the community. Please reach out if this is a feature you would like to see improved."
  }
}